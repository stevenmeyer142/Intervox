// CCubeMarcher.cp// Created by Steve on Mon, Dec 21, 1998 @ 1:41 PM.#include "NativeOpenGL.h"#include "CCubeMarcher.h"#include "CSlicesSet.h"#include "CTriangle.h"#include "CFacetLookup.h"#include "extensions/VulkanMesh.hpp"#include "CVertex.h"#include <cmath>#define kDebugMarcher 1int debugCounter = 0;CCubeMarcher::~CCubeMarcher(){	if (fBoolArray != NULL)	{		delete[] fBoolArray;		} }#pragma segment Main/*    is CSlicesSet or Boolarray used*/CCubeMarcher::CCubeMarcher(CSlicesSet *slicesSet, short resolution, short threshold, const C3DPoint &startPoint) : fBoolArray(NULL),        fWidth(slicesSet->GetWidth ()), fHeight(slicesSet->GetHeight ()), fDepth(slicesSet->GetDepth ()),	fResolution(resolution), fThreshold(threshold), fVertices(2000), fTriangles(2000), fStartPoint(startPoint), fSlicesSet(slicesSet){}CCubeMarcher::CCubeMarcher(bool *boolArray, short resolution, const C3DPoint &startPoint, short width, short height, short depth) :	fBoolArray(boolArray), fWidth(width), 	fHeight(height), fDepth(depth), fResolution(resolution), fThreshold(-1),         fVertices(2000), fTriangles(2000), fStartPoint(startPoint), fSlicesSet(NULL){}void CCubeMarcher::AddFacet(short x, short y, short z){        if (false)        {            ::printf("addfacet, x %d, y%d, z%d\n", x,y,z);        }	short index = 0;		if (GetBool(x, y + fResolution, z + fResolution))		index |= 1;                                // cast to get rid of ambiguity, change getBool short to long	if (GetBool((short)(x + fResolution), y + fResolution, z + fResolution))		index |= 2;		if (GetBool(x + fResolution, y + fResolution, z))		index |= 4;		if (GetBool(x, y + fResolution, z))		index |= 8;		if (GetBool(x, y, z + fResolution))		index |= 16;		if (GetBool(x + fResolution, y, z + fResolution))		index |= 32;		if (GetBool(x + fResolution, y, z))		index |= 64;		if (GetBool(x, y, z))		index |= 128;		CTriangle *triangles[kMaxTriangles] = { NULL, NULL, NULL, NULL, NULL };	CFacetLookup::GetTriangles (index, triangles, x, y, z, fResolution, this, fSlicesSet != NULL);		for (int i = 0; i < kMaxTriangles && triangles[i]; i++)	{        if (false && i == 0)        {            ::printf("FACET ADDED x%f, y%f, z%f\n", triangles[i]->fPoint1->fX, triangles[i]->fPoint1->fY, triangles[i]->fPoint1->fZ);        }				if (kScaleTriangles)		{			triangles[i]->Scale(kScaleFactor);		}		fVertices.InsertTriangle(triangles[i]);		fTriangles.InsertTriangle(triangles[i]);	}}bool CCubeMarcher::GetBool(short x, short y, short z){	if (fBoolArray)	{		// this is sloppy		 x /= fResolution;		 y /= fResolution;		 z /= fResolution;		return fBoolArray[(z * fHeight + y) * fWidth + x];	}	else	{		return (fSlicesSet->GetPixelValue (x, y, z) & fThreshold) != 0;	}}bool CCubeMarcher::GetBool(float x, float y, float z){   return GetBool((short)std::round(x), (short)std::round(y), (short)std::round(z));}void CCubeMarcher::MarchTheCubes(short resolution){	fResolution = resolution;	const short kResolution = fSlicesSet ? fResolution : 1;	#if __profile__	OSErr profileErr = -1;	profileErr = ProfilerInit(collectDetailed, bestTimeBase, 20, 1000);#endif	for (short z = 0; z < fDepth - kResolution; z += kResolution)	{		for (short y = 0; y < fHeight - kResolution; y += kResolution)		{			for (short x = 0; x < fWidth - kResolution; x += kResolution)			{				AddFacet(x, y, z);			}		} 	}	#if __profile__	if (profileErr == noErr)	{		ProfilerDump("\pBrain3D.prof");		ProfilerTerm();	}#endif	}bool CCubeMarcher::Get3DMesh(short resolution, GeometryInfo &geomInfo, std::shared_ptr<VulkanMesh> vulkanMesh, VkQueue queue){    bool result = false;		MarchTheCubes(resolution);			if (fTriangles.GetSize () > 0)	{#if 1        C3DPoint point(-128, -128, -128);        fVertices.Offset(point);        fVertices.scale(1.0f / 10.0f);#endif		fVertices.SetIndices ();		if (!fStartPoint.IsZero())		{			fVertices.Offset (fStartPoint);				}				geomInfo.numOfVertices = fVertices.GetSize();		geomInfo.numOfTriangles = fTriangles.GetSize();				        vulkanMesh->AddTriangles (fTriangles, fVertices, queue);        result = true;	} 		Cleanup();			return result;	}#pragma segment Mainvoid CCubeMarcher::Cleanup(){		fTriangles.RemoveAllItems ();	fVertices.RemoveAllItems ();		CVertex::Cleanup ();	CTriangle::Cleanup ();	}