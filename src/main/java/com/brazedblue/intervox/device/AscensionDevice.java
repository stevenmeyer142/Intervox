package com.brazedblue.intervox.device;import com.brazedblue.intervox.util.*;import com.brazedblue.intervox.tracker.*;import com.brazedblue.intervox.geometry.*;public class AscensionDevice extends PortDevice{	private byte[]	fByteDataBuffer = new byte[kDataRecordLength * 2];	private short[]	fShortDataBuffer = new short[kDataRecordLength];	private float[]	fPositionDataBuffer = new float[kPositionCount];	private float[]	fMatrixDataBuffer = new float[kMatrixCount];		static private final int kPositionCount = 3;	static private final int kMatrixCount = 9;		static private final int kDataRecordLength = kMatrixCount + kPositionCount;		// Ascension Manual, p72 "Position/Matrix"		static private final float kcmPerInch = 2.54f;	static private final float kMaxInches = 36;			// Ascension Manual, p72 "Position"	static private final float kMaxCentimeters = kMaxInches * kcmPerInch;	static private final short kMaxHex = 0x7FFF;	static private final float kPositionScaleFactor = kMaxCentimeters / kMaxHex;				// Ascension Manual, p72 "Position/Quaternion"	static private final float kMaxMatrix = .99996f;	static private final float kMatrixScaleFactor = kMaxMatrix / kMaxHex;	static private final String kPositionMatrixCmd = "Z";	static private final String kStreamCmd = "@";	static private final String kPointCmd = "B";			static private int gDebugCounter = 0;			public AscensionDevice()	{	}		public void Connecting(Tracker tracker)	{		tracker.SendString(kPositionMatrixCmd);		tracker.SendString(kStreamCmd);	}		static private void TranslateAscensionData(byte[] data, int length, short[] result)	{		for (int i = 0; i < length; i++)		{			result[i] = (short)(((short)(data[i * 2] & 0x7F) | (short)(data[i * 2 + 1] << 7)) << 2);		}	}	static private void TranslateHexToFloat(short[] data, int dataStart, int length, float[] result, int resultStart, float scaleFactor)	{		for (int i = 0; i < length; i ++)		{			result[resultStart + i] = data[dataStart + i] * scaleFactor;		}	}		static private void DebugCheckTranslation(byte[] data, int length, short[] result)	{		if (gDebugCounter > 200)		{			for (int i = 0; i < length; i ++)			{				System.out.println("Data   " + Debug.ByteToBinaryString(data[i * 2 + 1]) + Debug.ByteToBinaryString(data[i * 2]));				System.out.println("Result " + Debug.ShortToBinaryString(result[i]));			}		}		else		{			gDebugCounter++;		}	}		public void Disconnecting(Tracker tracker)	{		tracker.SendString(kPointCmd);		}		public void HandleOutput(DeviceOutput output, Tracker tracker)	{	}		public void SendToTracker(Tracker tracker)	{		}			//	 synchronize to ensure integrity of various buffers 	public synchronized DeviceOutput CreateOutputObject(ScrollingBuffer buffer)	{		DeviceOutput result = null;				// for now just find data records				int dataStart = -1;				for ( int i = 0; i < buffer.Length(); i++)		{			int ch = buffer.GetByte(i);			if ((ch & 0x80) != 0)			{				dataStart = i;				break;			}		}		if (dataStart > 0)			{			buffer.Scroll(dataStart);		}				if (kDataRecordLength * 2 <= buffer.Length())		{			try			{				if (buffer.GetByteArray(fByteDataBuffer, kDataRecordLength * 2))				{					TranslateAscensionData(fByteDataBuffer, kDataRecordLength, fShortDataBuffer);										TranslateHexToFloat(fShortDataBuffer, 0, kPositionCount, fPositionDataBuffer, 0, kPositionScaleFactor);					TranslateHexToFloat(fShortDataBuffer, kPositionCount, kMatrixCount, fMatrixDataBuffer, 0, kMatrixScaleFactor);						FloatPoint pos = new FloatPoint(fPositionDataBuffer[0], fPositionDataBuffer[1], fPositionDataBuffer[2]);					Matrix3 rotation = new Matrix3(fMatrixDataBuffer);					rotation.invert();										result = LocalizerPointOutput.GetNewLocalizerPoint(pos, rotation, DeviceOutput.STATION1);				}				else				{					NeuroSynchUtil.ErrorMessage("AscensionDevice.CreateOutputObject bugginess", 											NeuroSynchUtil.kNoDlog);				}			}			finally			{				buffer.Scroll(kDataRecordLength);			}		}						return result;	}	}