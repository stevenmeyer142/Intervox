package com.brazedblue.intervox.dicom;import java.io.*;import com.brazedblue.intervox.util.*;public class DicomDataSetInputStream  extends InputStream {	static private final String kDicomLabelString = "DICM";	static private final int kInitialIgnoreBytes = 128;		static public final int kFloatDoubleSize = 8;	static public final int kFloatSingleSize = 4;	static public final int kOtherWordSize = 2;	static public final int kLongSize = 4;	static public final int kShortSize = 2;		private int		fPos = 0;	private int		fBufferSize = 0;	private int		fMark = -1;	private byte[]		fBuffer = null;		static public final boolean kOpenEarlyFormatDicom = true;      public DicomDataSetInputStream(InputStream stream) throws IOException	{		fBufferSize = stream.available();		fBuffer = new byte[fBufferSize];				stream.read(fBuffer);   	}   	    public DicomDataSetInputStream(int initialSize) 	{		fBuffer = new byte[initialSize];   	}	    public void ReadStream(InputStream stream)  throws IOException	{		fBufferSize = stream.available();		if (fBufferSize > fBuffer.length)		{					if (Debug.fgDebugging)			{				NeuroSynchUtil.ErrorMessage("DicomDataSetInputStream's buffer needed to be resized.", NeuroSynchUtil.kNoDlog);			}			fBuffer = new byte[fBufferSize];								}				stream.read(fBuffer, 0, fBufferSize);		fPos = 0;		fMark = -1;   	}	public int available() throws IOException 	{		return (int)Math.max(fBufferSize - fPos, -1);    }			public boolean AtEnd() throws IOException	{		return available() <= 0;	}		public boolean ValidateDicomFile()  throws IOException	{		mark(0);		skip(kInitialIgnoreBytes);		String string = new String(ReadByteString(kDicomLabelString.length()));				boolean correctFile = string.equals(kDicomLabelString);				if (!correctFile && kOpenEarlyFormatDicom)		{			reset();			string = new String(ReadByteString(kDicomLabelString.length()));						correctFile = string.equals(kDicomLabelString);						if (!correctFile)			{				reset();				correctFile = true;			}				}		return correctFile;	}		public synchronized long skip(long n) throws IOException 	{		if (n <= available())		{			fPos += n;		}		else		{			throw new IOException("Unexpected end of file");		}				return n;	}		byte[] ReadByteString(int length) throws IOException	{		// to do- get rid of ending fill byte		byte[] array = new byte[length];				read(array);				return array;	}			// unsigned 4 bytes		// return as signed 8 bytes	public long ReadUnsignedLong()	 throws IOException	{		return ReadLittleEndianLong(kLongSize);	//	read 4 bytes but store in 8 for unsigned	}		// signed 4 bytes, return as such	public int ReadSignedLong() throws IOException	{		return (int)ReadLittleEndianLong(kLongSize);	}		public float ReadFloatSingle() throws IOException	{		return (float)ReadLittleEndianFloat(kFloatSingleSize);	}		public double ReadFloatDouble() throws IOException	{		return ReadLittleEndianFloat(kFloatDoubleSize);	}		public int ReadUnsignedShort() throws IOException	{		return (int)ReadLittleEndianLong(kShortSize);	}		public short ReadSignedShort() throws IOException	{		return (short)ReadLittleEndianLong(kShortSize);	}		public short ReadOtherWord() throws IOException	{		return (short)ReadLittleEndianLong(kOtherWordSize); 		}				// tag, VR and length		public DicomElementTag ReadTag() throws IOException	{		byte[] array = Read2ByteArray();		String group = NeuroSynchUtil.ByteToHexString(array[0]) + NeuroSynchUtil.ByteToHexString(array[1]);		array = Read2ByteArray();		String element = NeuroSynchUtil.ByteToHexString(array[0]) + NeuroSynchUtil.ByteToHexString(array[1]);				return new DicomElementTag(group, element);	}		public DicomValueRep ReadValueRep() throws IOException	{		DicomValueRep result = null;				mark(512);	// anything more than 2				byte[] array = new byte[2];		read(array);								String valueRepString = new String(array);			// check if element contains an explicit representation value			// I don't think this is exactly right, the app should know if implicit or explicit value			// reps are used by the data element.  The default is "Implicit VR Little Endian Transfer Syntax"			// but the files I have been reading are mixed explicit and implicit			// If the length value randomly generates a true result for the if expression, the following			// code would be incorrect 		if (DicomValueRep.IsAValueRep(valueRepString))	// explicit		{			result = new DicomValueRep(valueRepString, DicomValueRep.EXPLICIT);		}		else		{			reset();		}				return result;	}		public long ReadLittleEndianLong(int numOfBytes) throws IOException	{		long result = 0;				if (numOfBytes > 8)		{			NeuroSynchUtil.ErrorMessage("range error in DicomDataSetInputStream.ReadLittlEndianLong", NeuroSynchUtil.kNoDlog);		}				for (int i = 0; i < numOfBytes; i++)		{			int shiftedByte = read();			shiftedByte <<= (8 * i);	//	shift 8 bits to left			result |= shiftedByte;		}				return result;	}	public double ReadLittleEndianFloat(int numOfBytes) throws IOException	{		long longBits = ReadLittleEndianLong(numOfBytes);				return Double.longBitsToDouble(longBits);	}		public byte[] Read2ByteArray() throws IOException	{		byte[] result = new byte[2];		result[1] = (byte)read();		result[0] = (byte)read();				return result;	}		long GetPos()	{		return fPos;	}	public synchronized int read(byte b[], int off, int len) throws IOException 	{		if (len > available())		{			throw new IOException("Unexpected end of file");		}				System.arraycopy(fBuffer, fPos, b, off, len);				fPos += len;				return len;    }  	public synchronized int read() throws IOException {		if (available() <= 0)		{			throw new IOException("Unexpected end of file");		}				int result = fBuffer[fPos++] & 0xff;				return result;	}		public synchronized void reset() throws IOException 	{		if (fMark > -1)		{			fPos = fMark;		}    }		byte[] ReadBytesToEnd() throws IOException	{		byte[] array = new byte[available()];				read(array);						return array;	}		void SwapBytes(byte[] array, int bytesPerUnit)	{		if (bytesPerUnit > 1)	// flip for little endian		{			byte[] flipArray = new byte[bytesPerUnit];						for (int i = 0; i < array.length; i += bytesPerUnit)			{				for (int j = 0; j < bytesPerUnit; j++)				{					flipArray[(bytesPerUnit - 1) - j] = array[i + j];				}								System.arraycopy(flipArray, 0, array, i, bytesPerUnit);			}		}	}		void DebugDump()	{		if (Debug.fgDebugging)		{			System.out.println(toString());						int startPos = Math.max(fPos - 500,  0);			int endPos = Math.min(fPos + 500, fBufferSize);			System.out.write(fBuffer, startPos, fPos - startPos);			System.out.println("\rCurrentPos");			System.out.write(fBuffer, fPos, endPos - fPos);						System.out.println("");		}	} 	public synchronized void mark(int readlimit) 	{		fMark = fPos;	}	public boolean markSupported() 	{		return true;    }}