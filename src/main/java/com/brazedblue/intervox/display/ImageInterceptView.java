package com.brazedblue.intervox.display;import com.brazedblue.intervox.device.*;import com.brazedblue.intervox.geometry.*;import com.brazedblue.intervox.image.*;import com.brazedblue.intervox.registration.*;import com.brazedblue.intervox.util.Debug;import com.brazedblue.intervox.util.NeuroSynchUtil;import java.awt.*;import javax.vecmath.*;public class ImageInterceptView extends ImageSeriesView /* implements anInterface */ {  private String fDistanceText;  private int fDistanceTextOffset = 0;  private Font fDistanceTextFont;  private static final String kDistanceTextLabel = " cm";  private static final String kNoDistanceTextLabel = "... cm";  private static final String kMaxDistanceText = "999.9"; // ~10  meters)  private static final float kMaxValue = 999.9f;  private static boolean kDebugDump = Debug.fgDebugging;  public ImageInterceptView(ImageViewType viewType) {    super(viewType);  }  private Font GetDistanceTextFont() {    if (fDistanceTextFont == null) {      Font font = getFont();      int size = font.getSize();      if (size < 18) {        size = 18;      }      fDistanceTextFont = new Font(font.getName(), Font.BOLD, size);    }    return fDistanceTextFont;  }  //	need an override of Adorner  public void DisplayTrackerOutput(DeviceOutput output, TransformerAccess transformer) {    /*		Object realPoint = output.GetDataOfType(DeviceOutput.POINT_COORDINATE);    Object rotation = output.GetDataOfType(DeviceOutput.ROTATION_MATRIX);    if (transformer.CanTransform(output.GetSpaceID(), GetSpaceID()) && rotation != null    			&& realPoint != null)    {    	FloatPoint virtualPoint = new FloatPoint((FloatPoint)realPoint);    	virtualPoint = transformer.TransformPoint(virtualPoint, output.GetSpaceID(), GetSpaceID());    	Matrix3 matrix = (Matrix3)rotation;    	ThreeDVector xIncVector = new ThreeDVector(1, 0, 0);    	TrackerSettingsAccess trackerSettings = output.GetTrackerSettings();    	if (trackerSettings.IsUsingTrackerOffset())    	{    		CalculatedOffset offsetCalculations = trackerSettings.GetTrackerCalculatedOffset();    		Location3D offset = offsetCalculations.GetOffset();    		if (offset != null && !offset.equals(FloatPoint.kZero))    		{    			xIncVector.Set(offset);    		}    	}    			//	rotate x vector to pointer direction    	matrix.transform(xIncVector);    			//	rotate pointer direction from device space to local space    	xIncVector = transformer.TransformVector(xIncVector, output.GetSpaceID(), GetSpaceID());    	xIncVector.normalize();    	FloatPoint trackerPos = (FloatPoint)virtualPoint;    	int myAxis = fImageViewType.GetAxis();    	float distance = Float.NEGATIVE_INFINITY;    	if (xIncVector.Get(myAxis) != 0)    	{    		distance = (fPerspective.CurrentDepth() - trackerPos.Get(myAxis)) / xIncVector.Get(myAxis);    	}    	FloatPoint floatPoint = new FloatPoint(-1, -1, -1);    	floatPoint.Set(fPerspective.CurrentDepth(), myAxis);    	if (distance >= 0)    	{    		for (int axis = FloatPoint.X; axis <= FloatPoint.Z; axis++)    		{    			if (axis != myAxis)    			{    				float value = trackerPos.Get(axis)  + xIncVector.Get(axis) * distance;    				floatPoint.Set(value, axis);    			}    		}    		FloatPoint inverseTransformedPoint = new FloatPoint(floatPoint);    				// transform back to DeviceOutput space to get distance in Localizer space    		inverseTransformedPoint = transformer.TransformPoint(inverseTransformedPoint, GetSpaceID(), output.GetSpaceID());    		FloatPoint realTrackerPos = (FloatPoint)realPoint;    		distance = realTrackerPos.distance(inverseTransformedPoint);    	}    	DisplayPoint(floatPoint, null);    	UpdateDistanceText(distance);    }    */  }  private void UpdateDistanceText(float distance) {    if (isVisible()) {      Graphics g = getGraphics();      g.setColor(Color.black);      PaintDistanceText(g);      SetDistanceText(distance);      g.setColor(Color.white);      PaintDistanceText(g);      g.dispose();    }  }  public synchronized void paintComponent(Graphics g) {    super.paintComponent(g);    PaintDistanceText(g);  }  private void SetDistanceText(float distance) {    if (distance >= kMaxValue || distance < 0) {      fDistanceText = kNoDistanceTextLabel;    } else {      fDistanceText = NeuroSynchUtil.GetDecimalString(distance, 1);      fDistanceText += kDistanceTextLabel;    }  }  private void PaintDistanceText(Graphics g) {    if (fDistanceText != null) {      Font oldFont = g.getFont();      Font distanceTextFont = GetDistanceTextFont();      g.setFont(distanceTextFont);      FontMetrics fontMetrics = getFontMetrics(distanceTextFont);      Dimension imageDrawSize = GetImageViewSize();      int textbottom = imageDrawSize.height;      int vPos = textbottom - fontMetrics.getDescent();      if (fDistanceTextOffset <= 0) {        fDistanceTextOffset = fontMetrics.stringWidth(kMaxDistanceText + kDistanceTextLabel) + 6;      }      Color oldColor = g.getColor();      g.setColor(Color.white);      g.fillRect(          0, textbottom - fontMetrics.getHeight(), fDistanceTextOffset, fontMetrics.getHeight());      g.setColor(Color.red);      g.drawString(          fDistanceText, fDistanceTextOffset - fontMetrics.stringWidth(fDistanceText), vPos);      g.setFont(oldFont);      g.setColor(oldColor);    }  }  /*  	protected void DrawFocalPoint(Graphics g)  	{  		if (fImage != null)  		{  			Dimension imgSize = GetImageSize();  			g.setXORMode(Color.red);  			Color oldColor = g.getColor();  			g.setColor(Color.red);  			int height = Math.min(imgSize.height, getHeight());  			int width = Math.min(imgSize.width, getWidth());  			if (fFocalPoint.y >= 0 && fFocalPoint.y < height  					&& fFocalPoint.x >= 0 && fFocalPoint.x < width)  			{  				g.drawOval(fFocalPoint.x - 4, fFocalPoint.y - 4, 8, 8);  			}  			g.setColor(oldColor);  			g.setPaintMode();  		}  	}  */}