package com.brazedblue.intervox.display;import java.util.*;import java.awt.event.*;import java.awt.*;import javax.swing.*;import javax.swing.border.*;import javax.swing.event.*;import com.brazedblue.intervox.tracker.*;import com.brazedblue.intervox.geometry.*;import com.brazedblue.intervox.device.*;import com.brazedblue.intervox.util.*;import com.brazedblue.intervox.data.*;public class OffsetCalculationDisplay extends JPanel implements ActionListener {  		private Configuration 		fConfiguration;	private TrackerController	fTracker;		private JButton fCalcOffsetButton = null;	private JButton fDeleteOffsetButton = null;	private JButton fRenameOffsetButton = null;	private JList	fOffsetDisplay = null;		static private final String kRecordPosition = "Record Position";	static private final String kCalcOffsetPosition = "Calculate Offset";	static private final String kAddOffset = "Add";	static private final String kDeleteOffset = "Delete";	static private final String kRenameOffset = "Rename";	static private final String kGenericOffsetString = "Offset";		static private final int kMinimumPoints = 4;			static private boolean kDebugDump = Debug.fgDebugging && false;	static private FloatPoint gOffsetPoint = new FloatPoint();		static private final boolean kMessageIfNULL = true;		    public OffsetCalculationDisplay(TrackerController tracker, Configuration configuration) 	{		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));		fTracker = tracker;				fConfiguration = configuration;		JPanel controlPanel = new JPanel() {			public Dimension getMaximumSize() { return getPreferredSize(); }		};		add(controlPanel);		JButton button = new JButton(kRecordPosition);		controlPanel.add(button);		controlPanel.setBorder(BorderFactory.createRaisedBevelBorder());		OffsetCalculationTracker listener = new OffsetCalculationTracker(tracker, button);		button.addActionListener(listener);					fCalcOffsetButton = new JButton(kCalcOffsetPosition);		fCalcOffsetButton.setEnabled(false);		controlPanel.add(fCalcOffsetButton);				fCalcOffsetButton.addActionListener(this);				button = new JButton(kAddOffset);		controlPanel.add(button);		button.addActionListener(this);		 		fDeleteOffsetButton = new JButton(kDeleteOffset);		controlPanel.add(fDeleteOffsetButton);		fDeleteOffsetButton.addActionListener(this);		 		fRenameOffsetButton = new JButton(kRenameOffset);		controlPanel.add(fRenameOffsetButton);		fRenameOffsetButton.addActionListener(this);				fOffsetDisplay = new JList();		JScrollPane scrollPane = new JScrollPane(fOffsetDisplay);		scrollPane.setBorder(new TitledBorder(new BevelBorder(BevelBorder.RAISED), "Offsets"));		add(scrollPane);		UpdateList();		fOffsetDisplay.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);		ListSelectionListener l = new ListSelectionListener()		{  			public void valueChanged(ListSelectionEvent e)			{				SelectionChanged(e);			}		};		fOffsetDisplay.addListSelectionListener(l);				add(Box.createGlue());   }      private void UpdateButtons()   {   		CalculatedOffset offset = GetSelectedOffset(kMessageIfNULL);		fCalcOffsetButton.setEnabled(offset != null && offset.GetPointCount() >= kMinimumPoints);   }      private CalculatedOffset GetSelectedOffset(boolean messageIfNULL)   {   		CalculatedOffset result = fConfiguration.GetSelectedOffset();				if (result == null && messageIfNULL)		{			Debug.PrintStackTrace("Selected offset null"); 		}				return result;   }      private void AddOffset()   {   		String label = NeuroSynchUtil.GetUserInput("Add New Offset", "Label", kGenericOffsetString);				if (label != null)		{			fConfiguration.AddOffset(label);			UpdateList();			UpdateTracker();		}   }   	//	user changed selection   private void SelectionChanged(ListSelectionEvent e)   {   		int index = fOffsetDisplay.getMinSelectionIndex();	//	only one selection for now				if (index >= 0)		{			Vector offsets = fConfiguration.GetOffsets();			CalculatedOffset newOffset = (CalculatedOffset)offsets.elementAt(index);			if (newOffset != fConfiguration.GetSelectedOffset())			{				fConfiguration.SelectOffset(newOffset);				UpdateTracker();			}		}   }      public void SetConfiguration(Configuration config)   {   		fConfiguration = config;		UpdateList();		UpdateTracker();   }      private void UpdateTracker()   {   		fTracker.SetConfiguration(fConfiguration);   }      private void RenameOffset()   {   		CalculatedOffset offset = GetSelectedOffset(kMessageIfNULL);				if (offset != null)		{	   		String label = NeuroSynchUtil.GetUserInput("Rename Offset", "New Label", offset.GetLabel());						if (label != null)			{				offset.SetLabel(label);				UpdateList();				UpdateTracker();			}		}   }   private void DeleteOffset()   {   		fConfiguration.DeleteSelectedOffset();		UpdateList();		UpdateTracker();   }      private void UpdateList()   {   		Vector offsets = fConfiguration.GetOffsets();   		fOffsetDisplay.setListData(offsets);		   		CalculatedOffset selection = GetSelectedOffset(!kMessageIfNULL);		if (selection != null)		{			int selectionIndex = offsets.indexOf(selection);			fOffsetDisplay.setSelectedIndex(selectionIndex);		}		fRenameOffsetButton.setEnabled(selection != null);		fDeleteOffsetButton.setEnabled(selection != null);   }	public void actionPerformed(ActionEvent e)	{		if (e.getActionCommand().equals(kCalcOffsetPosition))		{			CalculateOffsetPosition1();			UpdateButtons();		}		else if (e.getActionCommand().equals(kAddOffset))		{			AddOffset();		}		else if (e.getActionCommand().equals(kDeleteOffset))		{			DeleteOffset();		}		else if (e.getActionCommand().equals(kRenameOffset))		{			RenameOffset();		}	} 		static public synchronized void OffsetPoint(FloatPoint transformedPt, FloatPoint offset, Matrix3 rotation)	{		gOffsetPoint.Set(offset);		rotation.transform(gOffsetPoint);				transformedPt.Add(gOffsetPoint);	} 		/*	CalculateOffsetPosition1 (using least squares)**	Pt(i) = [X(i), Y(i), Z(i)]  i = 1 ... number of points (at least 4)*	Pt(center) = [X(c), Y(c), Z(c)]			Center of sphere where points lie aproximately on the surface*	R = radius of sphere**	*	j = 2 ... number of points*	sqr(X(1) - X(c)) + sqr(Y(1) - Y(c)) + sqr(Z(1) - Z(c)) = sqr(R)*	sqr(X(j) - X(c)) + sqr(Y(j) - Y(c)) + sqr(Z(j) - Z(c)) = sqr(R) *	sqr(X(j) - X(c)) + sqr(Y(j) - Y(c)) + sqr(Z(j) - Z(c)) = sqr(X(1) - X(c)) + sqr(Y(1) - Y(c)) + sqr(Z(1) - Z(c))**		expanding the squares*	sqr(X(j)) - 2 * X(j) * X(c) + sqr(X(c)) + sqr(Y(j)) - 2 * Y(j) * Y(c) + sqr(Y(c)) + sqr(Z(j)) - 2 * Z(j) * Z(c) + sqr(Z(c))*		= sqr(X(1)) - 2 * X(1) * X(c) + sqr(X(c)) + sqr(Y(1)) - 2 * Y(1) * Y(c) + sqr(Y(c)) + sqr(Z(1)) - 2 * Z(1) * Z(c) + sqr(Z(c))**		Solving for X(c), Y(c), Z(c)**	2 * X(1) * X(c) - 2 * X(j) * X(c) + 2 * Y(1) * Y(c) - 2 * Y(j) * Y(c) + 2 * Z(1) * Z(c) - 2 * Z(j) * Z(c)*		= sqr(X(1)) - sqr(X(j)) + sqr(Y(1)) - sqr(Y(j)) + sqr(Z(1)) - sqr(Z(j))**	(X(1) - X(j)) * X(c) + (Y(1) - Y(j)) * Y(c) + (Z(1) - Z(j)) * Z(c)*		= (sqr(X(1)) - sqr(X(j)) + sqr(Y(1)) - sqr(Y(j)) + sqr(Z(1)) - sqr(Z(j))) / 2**	This can be written as a linear equation of form Ax = b, where**	A = | (X(1) - X(2)) , (Y(1) - Y(2)) , (Z(1) - Z(2)) |*		|    ...        ,     ...       ,    ...        |*		|    ...        ,     ...       ,    ...        |*		| (X(1) - X(j)) , (Y(1) - Y(j)) , (Z(1) - Z(j)) |**	x = | X(c) |*		| Y(c) |*		| Z(c) |*		*	b = |(sqr(X(1)) - sqr(X(2)) + sqr(Y(1)) - sqr(Y(2)) + sqr(Z(1)) - sqr(Z(2))) / 2 |*		|                                  ...                                       |*		|                                  ...                                       |*		|(sqr(X(1)) - sqr(X(j)) + sqr(Y(1)) - sqr(Y(j)) + sqr(Z(1)) - sqr(Z(j))) / 2 |**	*	when the number of points is greater than 4, the least squares solution is*	A(transpose) * A * x = A(transpose) * b**	x = inverse(A(transpose) * A ) * A(transpose) * b*/			private void CalculateOffsetPosition1()	{   		CalculatedOffset offset = GetSelectedOffset(kMessageIfNULL);				FloatPoint result = new FloatPoint(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY);		if (offset != null && offset.GetPointCount() >= kMinimumPoints)		{			Vector points = offset.GetPoints();			Vector angles = offset.GetAngles();			int size = offset.GetPointCount();						FloatPoint pt1 = (FloatPoint)points.elementAt(0);			final int kFloatPointMatrixDiff = 1 - FloatPoint.X;						ArbitraryFloatMatrix matrixA = new ArbitraryFloatMatrix(size - 1, 3);			ArbitraryFloatMatrix matrixB = new ArbitraryFloatMatrix(size - 1, 1);			for (int i = 1; i < size; i++)			{				FloatPoint pti = (FloatPoint)points.elementAt(i);				float bValue = 0;				for (int axis = FloatPoint.X; axis <= FloatPoint.Z; axis++)				{					float value_1 = pt1.Get(axis);					float value_i = pti.Get(axis);					 					matrixA.Set(i, axis + kFloatPointMatrixDiff, value_1 - value_i);										bValue += value_1 * value_1 - value_i * value_i;				}								matrixB.Set(i, 1, bValue / 2);			}							//	matrix to be inverted			ArbitraryFloatMatrix invertMatrix = new ArbitraryFloatMatrix(3, 3);			if (size == 4)	// no least squares			{				invertMatrix.Set(matrixA);			}			else			{				ArbitraryFloatMatrix matrixATranspose = new ArbitraryFloatMatrix(matrixA);								matrixATranspose.Transpose();										// invertMatrix = A(transpose) * A				matrixATranspose.Multiply(matrixA, invertMatrix);									// matrixATranspose = A(transpose) * b				matrixATranspose.Multiply(matrixB);				matrixB = matrixATranspose;			}							//	I use Matrix3 because I haven't done an inverse implementation for ArbitraryFloatMatrix			Matrix3 tempMatrix3 = new Matrix3();			tempMatrix3.Set(invertMatrix);			tempMatrix3.invert();			invertMatrix.Set(tempMatrix3);							//	calculation will set matrixB to resulting [3 X 1] matrix with rows equaling x,y,z coordinates of sphere center			invertMatrix.Multiply(matrixB, matrixB);						FloatPoint globalCenter = new FloatPoint();			for (int axis = FloatPoint.X; axis <= FloatPoint.Z; axis++)			{				globalCenter.Set((float)matrixB.Get(axis + kFloatPointMatrixDiff, 1), axis);				result.Set(0, axis);			}			Matrix3 rotation = new Matrix3();						Vector offsets = new Vector();			for (int i = 0; i < size; i++)			{				FloatPoint ptCopy = new FloatPoint((FloatPoint)points.elementAt(i));				rotation.Set((Matrix3)angles.elementAt(i));if (Debug.fgDebugging && false){	System.out.println("Distance to center " + ptCopy.distance(globalCenter));}				ptCopy.Subtract(globalCenter);	// center to point				ptCopy.negate();	//	point to center								rotation.invert();												rotation.transform(ptCopy);if (Debug.fgDebugging && false){	System.out.println("local offset " + ptCopy);}								offsets.addElement(ptCopy);				result.Add(ptCopy);	//	 used to calculate average			}						result.scale(1f / size);						FloatPoint deviation = new FloatPoint();				for (int i = 0; i < size; i++)			{				FloatPoint point = (FloatPoint)offsets.elementAt(i);								for (int axis = FloatPoint.X; axis <= FloatPoint.Z; axis++)				{					float value = point.Get(axis) - result.Get(axis);					deviation.Set(value * value + deviation.Get(axis), axis);				}			}			for (int axis = FloatPoint.X; axis <= FloatPoint.Z; axis++)			{				float value = (float)Math.sqrt(deviation.Get(axis));				deviation.Set(value / size, axis);			}						offset.SetOffset(result);			offset.SetDeviation(deviation);			UpdateList();						offset.ClearPointsAndAngles();		}		}								private void AddPointAndAngle(FloatPoint point, Matrix3 rotation)	{		CalculatedOffset offset = GetSelectedOffset(!kMessageIfNULL);		if (offset == null)		{			fConfiguration.AddOffset(kGenericOffsetString);			UpdateList();			UpdateTracker();		}				if (offset != null)		{			offset.AddPointAndAngle(point, rotation);		}				UpdateButtons();	}		class OffsetCalculationTracker implements TrackerListener, ActionListener	{		FloatPoint			fLastPoint = null;		Matrix3				fLastRotation = null;		AbstractButton 		fRecordPositionButton;		TrackerController	fTracker;				OffsetCalculationTracker(TrackerController controller, AbstractButton regButton)		{			fRecordPositionButton = regButton;			fTracker = controller;						controller.AddTrackerListener(this, 0, true, DeviceOutput.ALL_STATIONS);	// 3rd arg wants transformation			fRecordPositionButton.setEnabled(controller.IsConnected());		}								public void DataRetrieved(DeviceOutput output)		{			Object data = output.GetDataOfType(DeviceOutput.ORIG_COORDINATE);						if (data != null)			{				if (output.GetStation() == DeviceOutput.STATION1)				{					Object rotation = output.GetDataOfType(DeviceOutput.ROTATION_MATRIX);										if (rotation != null)					{						fLastPoint = (FloatPoint)data;												fLastRotation = (Matrix3)rotation;					}					else					{						NeuroSynchUtil.ErrorMessage("OffsetCalculationTracker.DataRetrieved: No angle orientation for point", NeuroSynchUtil.kNoDlog);					}				}			}			data = output.GetDataOfType(DeviceOutput.COMMAND);						if (data != null && TrackerController.kConnectCmd.equals(data))			{				Boolean state = (Boolean)output.GetDataOfType(DeviceOutput.STATE);				boolean enabled = state.booleanValue();								fRecordPositionButton.setEnabled(enabled);			}					}				public Component GetComponent()		{			return OffsetCalculationDisplay.this;		}						void RecordPosition()		{			if (fLastPoint != null && fLastRotation != null)			{				AddPointAndAngle(fLastPoint, fLastRotation);								fLastPoint = null;				fLastRotation = null;			}			else			{				NeuroSynchUtil.ErrorMessage("Not receiving tracker data", NeuroSynchUtil.kShowDlog);			}		}			public void actionPerformed(ActionEvent e)		{			if (e.getActionCommand().equals(kRecordPosition))			{				RecordPosition();			}		}			}}