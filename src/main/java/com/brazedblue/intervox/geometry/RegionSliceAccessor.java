package com.brazedblue.intervox.geometry;import com.brazedblue.intervox.image.*;import com.brazedblue.intervox.util.*;import java.awt.*;import java.util.*;public class RegionSliceAccessor implements Region2DAccessor, RGBArrayModifier {  RegionSlice fSlice;  int fSliceIndex = 0;  PixelData fPixels;  //	RegionSelectionActions	fCachedActions;  RegionsOfInterest fRegions;  Region3DModel fRegion;  int fRegionValue = 1;  int fLowValue = 0;  int fHighValue = 128;  //	colors  int fRangeColor = Color.green.getRGB();  int fRegionColor = Color.blue.getRGB();  //	int						fPointColor = Color.red.getRGB();  //	int 					fEdgeColor = Color.blue.getRGB();  boolean fDisplayRegion = true;  public RegionSliceAccessor() {}  /*  		//	 overridden  	private void PrepareToSeed()  	{  		RegionSelectionActions actions = GetActions();  		if (actions != null)  		{  			Point pt = null;  			for (EdgePointEnumeration pts = actions.GetEdgePoints(); pts.hasMoreElements(); )  			{  				pt = pts.GetNextPoint(pt);  				MarkPixel(pt.x, pt.y);  			}  		}  	}  		//	 overridden  	private void CompleteSeeding()  	{  		RegionSelectionActions actions = GetActions();  		if (actions != null)  		{  			Point pt = null;  			for (EdgePointEnumeration pts = actions.GetEdgePoints(); pts.hasMoreElements(); )  			{  				pt = pts.GetNextPoint(pt);  				UnMarkPixel(pt.x, pt.y);  			}  			actions.SetShouldSeed(false);  		}  	}  	private RegionSelectionActions GetActions()  	{  		return fRegion != null ? fRegion.GetActions(fSliceIndex) : null;  	}  */  public void SetRegions(RegionsOfInterest regions) {    fRegions = regions;    fSliceIndex = 0;  }  /*  	public void ClearEdgeLines()  	{  		fSlice.UnMark(fRegionValue);  		fCachedActions = null;  		RegionSelectionActions actions = GetActions();  		if (actions != null)  		{  			actions.ClearEdgeLines();  		}  		SeedTheRegions();  	}  */  public String GetCurrentRegionLabel() {    String result = null;    if (fRegion != null) {      result = fRegion.GetLabel();    }    return result;  }  public void CopyRegion(String fromRegion, String toRegion) {    fRegions.CopyRegion(fromRegion, toRegion);  }  public boolean IsFillPixel(int x, int y) {    boolean result = false;    int mark = fSlice.GetMark(x, y);    if ((mark & fRegionValue) == 0) {      int value = fPixels.GetPixelValue(x, y);      result = value >= fLowValue && value <= fHighValue;    }    return result;  }  public int GetRangeLow() {    return fLowValue;  }  public int GetRangeHigh() {    return fHighValue;  }  /*  	public void ClearSeedPoints()  	{  		fSlice.UnMark(fRegionValue);  		fCachedActions = null;  		RegionSelectionActions actions = GetActions();  		if (actions != null)  		{  			actions.ClearSeedPoints();  		}  	}  	protected void SetPixelsAndRegion(PixelData pixels, RegionSlice slice, boolean deleteCache)  	{  		fSlice = slice;  		fPixels = pixels;  		if (deleteCache)  		{  			fCachedActions = null;  		}  		RegionSelectionActions sliceActions = GetActions();  		if (sliceActions != null && (sliceActions.ShouldSeed()||  			(fCachedActions != null && !sliceActions.HasPoints() && fCachedActions.HasPoints())))  		{  			SeedTheRegions();	// seed with the cached points  		}  		fCachedActions = sliceActions;  	}  	public void SetToCurrentSlice(int whichSlice, PixelData pixels)  	{  		int oldSliceIndex = fSliceIndex;  		fSliceIndex = whichSlice;  		RegionSlice slice = fRegions.GetRegionSlice(whichSlice);  		SetPixelsAndRegion(pixels, slice, Math.abs(whichSlice - oldSliceIndex) > 1);  	}  	public void ClearAllEdgeLines()  	{  		fRegions.UnMarkAllSlices(fRegionValue);  		if (fRegion != null)  		{  			fRegion.ClearAllEdgeLines();  		}  	}  	public void ClearAllSeedPoints()  	{  		fRegions.UnMarkAllSlices(fRegionValue);  		if (fRegion != null)  		{  			fRegion.ClearAllSeedPoints();  		}  	}  */  public int GetDisplayRegionValue() {    return fRegionValue;  }  public void SetDisplayRegion(boolean display) {    fDisplayRegion = display;  }  /*  	public boolean IsFillPixel(int x, int y)  	{  		boolean result = false;  		int mark = fSlice.GetMark(x, y);  		if ((mark & fRegionValue) == 0)  		{  			int value = fPixels.GetPixelValue(x, y);  			result = value >= fLowValue && value <= fHighValue;  		}  		return result;  	}  */  public void UnMarkPixel(int x, int y) {    int mark = fSlice.GetMark(x, y);    if ((mark & fRegionValue) != 0) {      mark -= fRegionValue;    }    fSlice.MarkPixel(x, y, mark);  }  public void MarkPixel(int x, int y) {    int mark = fSlice.GetMark(x, y);    mark |= fRegionValue;    fSlice.MarkPixel(x, y, mark);  }  public void SetSelectedRegion(String whichRegion) {    Region3DModel newRegion = fRegions.GetRegionWithLabel(whichRegion);    if (newRegion != fRegion) {      fRegion = newRegion;      fRegionValue = fRegion.GetRegionValue();      fLowValue = fRegion.GetRangeLow();      fHighValue = fRegion.GetRangeHigh();    }  }  public void UpdateRGBArray(int[] rgbArray) {    if (RegionSelectorFrame.kTrace) {      System.out.println("RegionSliceAccessor.UpdateRGBArray");    }    int height = fPixels.GetHeight();    int width = fPixels.GetWidth();    if (Debug.fgDebugging && (height * width != rgbArray.length)) {      NeuroSynchUtil.ErrorMessage(          "height and width don't match in RegionSliceAccessor.UpdateRGBArray(rgbArray)",          NeuroSynchUtil.kNoDlog);      return;    }    int i = 0;    for (int y = 0; y < height; y++) {      for (int x = 0; x < width; x++, i++) {        boolean marked = false;        if (fDisplayRegion) {          int mark = fSlice.GetMark(x, y);          if ((mark & fRegionValue) != 0) {            rgbArray[i] = fRegionColor;            marked = true;          }        }        if (!marked) {          int pixel = fPixels.GetPixelValue(x, y);          if (pixel <= fHighValue && pixel >= fLowValue) {            rgbArray[i] = fRangeColor;          }        }      }    }    /*			//	mark the seed points    RegionSelectionActions sliceActions = GetActions();    if (sliceActions != null)    {    	for (Enumeration iter = sliceActions.GetPoints(); iter.hasMoreElements(); )    	{    		Point pt = (Point)iter.nextElement();    		rgbArray[pt.y * width + pt.x] = fPointColor;    		if (pt.x < width - 1)    			rgbArray[pt.y * width + pt.x + 1] = fPointColor;    		if (pt.x > 0)    			rgbArray[pt.y * width + pt.x - 1] = fPointColor;    		if (pt.y < height - 1)    			rgbArray[(pt.y + 1) * width + pt.x] = fPointColor;    		if (pt.y > 0)    			rgbArray[(pt.y - 1) * width + pt.x] = fPointColor;    	}    	Point pt = null;    	for (EdgePointEnumeration pts = sliceActions.GetEdgePoints(); pts.hasMoreElements(); )    	{    		pt = pts.GetNextPoint(pt);    		rgbArray[(pt.y - 1) * width + pt.x] = fEdgeColor;    	}    } */  }  /*  	public void AddBoundaryPoint(int x, int y)  	{  		RegionSelectionActions actions = GetActions();  		if (actions != null)  		{  			actions.AddEdgePoint(x, y);  		}  	}  	public void BoundaryPointsAdded()  	{  		RegionSelectionActions actions = GetActions();  		if (actions != null)  		{  			actions.LastEdgePointAdded();  		}  	}  	public boolean AddSeedPoint(int x, int y)  	{  		boolean result = false;  		PrepareToSeed();  		SeedFill2D seedFill = new SeedFill2D();  		if (seedFill.SeedFill(x, y, this, new Rectangle(0, 0, fSlice.GetWidth(), fSlice.GetHeight())))  		{  			RegionSelectionActions actions = GetActions();  			if (actions != null)  			{  				actions.AddPoint(x,y);  			}  			result = true;  		}  		CompleteSeeding();  		return result;  	}  	public void SeedTheRegions()  	{  		fSlice.UnMark(fRegionValue);  		RegionSelectionActions sliceActions = GetActions();  		if (sliceActions != null)  		{  			PrepareToSeed();  			SeedFill2D seedFill = new SeedFill2D();  			Rectangle bounds = new Rectangle(0, 0, fSlice.GetWidth(), fSlice.GetHeight());  			Enumeration iter = sliceActions.GetPoints();  			boolean usingCache = false;  			if (!iter.hasMoreElements() && fCachedActions != null)  			{  				iter = fCachedActions.GetPoints();  				usingCache = true;  			}  			for (; iter.hasMoreElements(); )  			{  				Point pt = (Point)iter.nextElement();  				if (!seedFill.SeedFill(pt.x, pt.y, this, bounds))  				{  					if (!usingCache)  					{  						sliceActions.RemovePoint(pt);  					}  				}  				else  if (usingCache)  				{  					sliceActions.AddPoint(pt.x, pt.y);  				}  			}  			CompleteSeeding();  		}  	}  */  public Region3DModel GetCurrentRegion() {    return fRegion;  }  public void SetLowHighValues(int low, int high) {    fLowValue = low;    fHighValue = high;    if (fRegion != null) {      fRegion.SetLowHighValues(low, high);    }  }}