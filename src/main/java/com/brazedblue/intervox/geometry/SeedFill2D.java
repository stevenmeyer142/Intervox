package com.brazedblue.intervox.geometry;import com.brazedblue.intervox.image.RegionSelectorFrame;import java.awt.Rectangle;public class SeedFill2D {  SeedFillSegmentStack fStack = new SeedFillSegmentStack();  int fxLow;  int fxHigh;  int fyLow;  int fyHigh;  public SeedFill2D() {}  public boolean SeedFill(int x, int y, Region2DAccessor accessor, Rectangle boundingBox) {    if (RegionSelectorFrame.kTrace) {      System.out.println(          "SeedFill2D.SeedFill, x: " + Integer.toString(x) + ", y: " + Integer.toString(y));    }    boolean result = false;    fxLow = boundingBox.x;    fxHigh = boundingBox.x + boundingBox.width - 1;    fyLow = boundingBox.y;    fyHigh = boundingBox.y + boundingBox.height - 1;    if (x >= fxLow && x <= fxHigh && y >= fyLow && y <= fyHigh) {      fStack.Reset();      //	Code grabbed from the book "Graphic Gems", first volume      int left;      if (!accessor.IsFillPixel(x, y)) return result;      Push(y, x, x, 1); // needed in some cases      Push(y + 1, x, x, -1); // seed segment (popped 1st)      SeedFillSegment seg = new SeedFillSegment(0, 0, 0, 1); // 	need to allocate something      while (fStack.GetSize() > 0) {        // pop segment off stack and fill a neighboring scan line        Pop(seg);        // segment of scan line y-dy for x1<=x<=x2 was previously filled,        // now explore adjacent pixels in scan line y        for (x = seg.fLeftX; x >= fxLow && accessor.IsFillPixel(x, seg.fY); x--)          accessor.MarkPixel(x, seg.fY);        if (x >= seg.fLeftX) {          for (x++; x < seg.fRightX && !accessor.IsFillPixel(x, seg.fY); x++)            ;          left = x;          if (x >= seg.fRightX) {            continue;          }        } else {          left = x + 1;          if (left < seg.fLeftX) {            Push(seg.fY, left, seg.fLeftX - 1, -seg.fDY); // leak on left?          }          x = seg.fLeftX + 1;        }        do {          for (; x <= fxHigh && accessor.IsFillPixel(x, seg.fY); x++) accessor.MarkPixel(x, seg.fY);          Push(seg.fY, left, x - 1, seg.fDY);          if (x > seg.fRightX) Push(seg.fY, seg.fRightX, x - 1, -seg.fDY); // leak on right?          for (x++; x < seg.fRightX && !accessor.IsFillPixel(x, seg.fY); x++)            ;          left = x;        } while (x < seg.fRightX);      }      result = true;    }    return result;  }  private void Push(int y, int leftX, int rightX, int dy) {    if (y + dy <= fyHigh && y + dy >= fyLow) {      fStack.Push(y, leftX, rightX, dy);    }  }  private void Pop(SeedFillSegment seg) {    fStack.Pop(seg);    seg.fY += seg.fDY;  }}