package com.brazedblue.intervox.geometry;import java.awt.Rectangle;public class SeedFill3D {  SeedFillSegment3DStack fStack = new SeedFillSegment3DStack();  int fxLow;  int fxHigh;  int fyLow;  int fyHigh;  int fzLow;  int fzHigh;  public SeedFill3D() {}  public boolean SeedFill(      int x, int y, int z, Region3DAccessor accessor, Rectangle boundingBox, int zLow, int zHigh) {    boolean result = false;    fxLow = boundingBox.x;    fxHigh = boundingBox.x + boundingBox.width - 1;    fyLow = boundingBox.y;    fyHigh = boundingBox.y + boundingBox.height - 1;    fzLow = zLow;    fzHigh = zHigh - 1;    if (x >= fxLow && x <= fxHigh && y >= fyLow && y <= fyHigh && z >= fzLow && z <= fzHigh) {      fStack.Reset();      //	Code grabbed from the book "Graphic Gems", first volume      int left;      if (!accessor.IsFillPixel(x, y, z)) return result;      SeedFillSegment3D seg = new SeedFillSegment3D(y, z, x, x, 1, 0);      Push(seg, x, x, 1, 0); // needed in some cases      seg.fY += 1;      Push(seg, x, x, -1, 0); // seed segment (popped 1st)      while (fStack.GetSize() > 0) {        // pop segment off stack and fill a neighboring scan line        Pop(seg);        // segment of scan line y-dy for x1<=x<=x2 was previously filled,        // now explore adjacent pixels in scan line y        for (x = seg.fLeftX; x >= fxLow && accessor.IsFillPixel(x, seg.fY, seg.fZ); x--)          accessor.MarkPixel(x, seg.fY, seg.fZ);        if (x >= seg.fLeftX) {          for (x++; x < seg.fRightX && !accessor.IsFillPixel(x, seg.fY, seg.fZ); x++)            ;          left = x;          if (x >= seg.fRightX) {            continue;          }        } else {          left = x + 1;          if (left < seg.fLeftX) {            Push(seg, left, seg.fLeftX - 1, -seg.fDY, -seg.fDZ); // leak on left?          }          x = seg.fLeftX + 1;        }        do {          for (; x <= fxHigh && accessor.IsFillPixel(x, seg.fY, seg.fZ); x++)            accessor.MarkPixel(x, seg.fY, seg.fZ);          if (seg.fDY == 0) {            Push(seg, left, x - 1, 1, 0);            Push(seg, left, x - 1, -1, 0);            Push(seg, left, x - 1, 0, seg.fDZ);          } else // seg.fDZ == 0          {            Push(seg, left, x - 1, 0, 1);            Push(seg, left, x - 1, 0, -1);            Push(seg, left, x - 1, seg.fDY, 0);          }          if (x > seg.fRightX) Push(seg, seg.fRightX, x - 1, -seg.fDY, -seg.fDZ); // leak on right?          for (x++; x < seg.fRightX && !accessor.IsFillPixel(x, seg.fY, seg.fZ); x++)            ;          left = x;        } while (x < seg.fRightX);      }      result = true;    }    return result;  }  private void Push(SeedFillSegment3D seg, int leftX, int rightX, int dy, int dz) {    seg.fZ += dz;    seg.fY += dy;    if (seg.fY <= fyHigh && seg.fY >= fyLow && seg.fZ <= fzHigh && seg.fZ >= fzLow) {      fStack.Push(seg.fY, seg.fZ, leftX, rightX, dy, dz);    }  }  private void Pop(SeedFillSegment3D seg) {    fStack.Pop(seg);  }}