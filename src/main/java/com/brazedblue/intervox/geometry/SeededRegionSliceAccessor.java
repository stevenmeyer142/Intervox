package com.brazedblue.intervox.geometry;import java.awt.*;import java.util.*;import com.brazedblue.intervox.image.*;import com.brazedblue.intervox.util.*;public class SeededRegionSliceAccessor extends RegionSliceAccessor {  	RegionSelectionActions	fCachedActions;	int						fPointColor = Color.red.getRGB();	int 					fEdgeColor = Color.blue.getRGB();    public SeededRegionSliceAccessor() {    }	private void PrepareToSeed()	{		RegionSelectionActions actions = GetActions();				if (actions != null)		{			Point pt = null;			for (EdgePointEnumeration pts = actions.GetEdgePoints(); pts.hasMoreElements(); )			{				pt = pts.GetNextPoint(pt);								MarkPixel(pt.x, pt.y);			}		}	}	private void CompleteSeeding()	{		RegionSelectionActions actions = GetActions();				if (actions != null)		{			Point pt = null;			for (EdgePointEnumeration pts = actions.GetEdgePoints(); pts.hasMoreElements(); )			{				pt = pts.GetNextPoint(pt);								UnMarkPixel(pt.x, pt.y);			}						actions.SetShouldSeed(false);		}	}		private RegionSelectionActions GetActions()	{		return fRegion != null ? fRegion.GetActions(fSliceIndex) : null;	}		public void ClearSeedPoints()	{		fSlice.UnMark(fRegionValue);		fCachedActions = null;				RegionSelectionActions actions = GetActions();				if (actions != null)		{			actions.ClearSeedPoints();		}	}	public void ClearEdgeLines()	{		fSlice.UnMark(fRegionValue);		fCachedActions = null;		RegionSelectionActions actions = GetActions();				if (actions != null)		{			actions.ClearEdgeLines();		}				SeedTheRegions();	}		protected void SetPixelsAndRegion(PixelData pixels, RegionSlice slice, boolean deleteCache)	{		fSlice = slice;		fPixels = pixels;				if (deleteCache)		{			fCachedActions = null;		}				RegionSelectionActions sliceActions = GetActions();				if (sliceActions != null && (sliceActions.ShouldSeed()|| 			(fCachedActions != null && !sliceActions.HasPoints() && fCachedActions.HasPoints())))		{			SeedTheRegions();	// seed with the cached points		}				fCachedActions = sliceActions;	}		public void SetToCurrentSlice(int whichSlice, PixelData pixels)	{		int oldSliceIndex = fSliceIndex;		fSliceIndex = whichSlice;		RegionSlice slice = fRegions.GetRegionSlice(whichSlice);		SetPixelsAndRegion(pixels, slice, Math.abs(whichSlice - oldSliceIndex) > 1);	}		public void ClearAllEdgeLines()	{				fRegions.UnMarkAllSlices(fRegionValue);				if (fRegion != null)		{			fRegion.ClearAllEdgeLines();		}		}		public void ClearAllSeedPoints()	{				fRegions.UnMarkAllSlices(fRegionValue);				if (fRegion != null)		{			fRegion.ClearAllSeedPoints();		}		}		public void SetSelectedRegion(String whichRegion)	{		Region3DModel oldRegion = fRegion;				super.SetSelectedRegion(whichRegion);		if (oldRegion != fRegion)		{			fCachedActions = null;		}	}		public void UpdateRGBArray(int[] rgbArray)	{		int height = fPixels.GetHeight();		int width = fPixels.GetWidth();				if (Debug.fgDebugging && (height * width != rgbArray.length) )		{			NeuroSynchUtil.ErrorMessage("height and width don't match in RegionSliceAccessor.UpdateRGBArray(rgbArray)", 					NeuroSynchUtil.kNoDlog);			return;		}				super.UpdateRGBArray(rgbArray);/*				int i = 0;		for (int y = 0; y < height; y++)		{			for (int x = 0; x < width; x++, i++)			{				boolean marked = false;				if (fDisplayRegion)				{					int mark = fSlice.GetMark(x, y);					if ((mark & fRegionValue) != 0)					{						rgbArray[i] = fRegionColor;						marked = true;					}									}				if (!marked)				{					int pixel = fPixels.GetPixelValue(x, y);										if (pixel <= fHighValue && pixel >= fLowValue)					{						rgbArray[i] = fRangeColor;					}				}			}				} */			//	mark the seed points		RegionSelectionActions sliceActions = GetActions();				if (sliceActions != null)		{			for (Enumeration iter = sliceActions.GetPoints(); iter.hasMoreElements(); )			{				Point pt = (Point)iter.nextElement();								rgbArray[pt.y * width + pt.x] = fPointColor;				if (pt.x < width - 1)					rgbArray[pt.y * width + pt.x + 1] = fPointColor;				if (pt.x > 0)					rgbArray[pt.y * width + pt.x - 1] = fPointColor;				if (pt.y < height - 1)					rgbArray[(pt.y + 1) * width + pt.x] = fPointColor;				if (pt.y > 0)					rgbArray[(pt.y - 1) * width + pt.x] = fPointColor;			}						Point pt = null;			for (EdgePointEnumeration pts = sliceActions.GetEdgePoints(); pts.hasMoreElements(); )			{				pt = pts.GetNextPoint(pt);								rgbArray[(pt.y - 1) * width + pt.x] = fEdgeColor;			}		}			}	public void AddBoundaryPoint(int x, int y)	{		RegionSelectionActions actions = GetActions();				if (actions != null)		{			actions.AddEdgePoint(x, y);		}	}		public void BoundaryPointsAdded()	{		RegionSelectionActions actions = GetActions();				if (actions != null)		{			actions.LastEdgePointAdded();		}	}				public boolean AddSeedPoint(int x, int y)	{		boolean result = false;				PrepareToSeed();				SeedFill2D seedFill = new SeedFill2D();		if (seedFill.SeedFill(x, y, this, new Rectangle(0, 0, fSlice.GetWidth(), fSlice.GetHeight())))		{			RegionSelectionActions actions = GetActions();			if (actions != null)			{				actions.AddPoint(x,y);			}			result = true;		}				CompleteSeeding();				return result;	}		public void SeedTheRegions()	{		fSlice.UnMark(fRegionValue);		RegionSelectionActions sliceActions = GetActions();				if (sliceActions != null)		{			PrepareToSeed();						SeedFill2D seedFill = new SeedFill2D();			Rectangle bounds = new Rectangle(0, 0, fSlice.GetWidth(), fSlice.GetHeight());						Enumeration iter = sliceActions.GetPoints();			boolean usingCache = false;						if (!iter.hasMoreElements() && fCachedActions != null)			{				iter = fCachedActions.GetPoints();				usingCache = true;			}						for (; iter.hasMoreElements(); )			{				Point pt = (Point)iter.nextElement();								if (!seedFill.SeedFill(pt.x, pt.y, this, bounds))				{					if (!usingCache)					{						sliceActions.RemovePoint(pt);					}				}				else  if (usingCache)				{					sliceActions.AddPoint(pt.x, pt.y);				}			}						CompleteSeeding();		}	}}