package com.brazedblue.intervox.geometry;import javax.vecmath.*;import com.brazedblue.intervox.util.*;public class ThreeDVector extends Vector3f implements Cloneable, Location3D  {  	static final long serialVersionUID =  -1038402605351327577L;    public ThreeDVector(float xValue, float yValue, float zValue) 	{		super(xValue, yValue, zValue);    }    public ThreeDVector() 	{    }	    public ThreeDVector(Location3D start, Location3D end) 	{		super(end.GetFloat(X_AXIS) - start.GetFloat(X_AXIS), end.GetFloat(Y_AXIS) - start.GetFloat(Y_AXIS),						end.GetFloat(Z_AXIS) - start.GetFloat(Z_AXIS));    }		public ThreeDVector(Location3D location) 	{		super(location.GetFloat(Location3D.X_AXIS), location.GetFloat(Location3D.Y_AXIS), location.GetFloat(Location3D.Z_AXIS));    }	public ThreeDVector(Tuple3f other) 	{		super(other.x, other.y, other.z);    }	 public boolean Equals(Location3D other)	 {	 	boolean result = true;				for (int i = Location3D.X_AXIS;  i < Location3D.Z_AXIS; i++)		{			if (this.GetFloat(i) != other.GetFloat(i))			{				result = false;				break;			}		}				return result;	 }	 	static public ThreeDVector CalculateCentroid(ThreeDVector[] vectorList)	{		ThreeDVector result = new ThreeDVector(0,0,0);		int numOfVectors = vectorList.length;		for (int i = 0; i < numOfVectors; i++)		{			result.add(vectorList[i]);		}				float scaleFactor = 1f / (float)numOfVectors;		result.scale(scaleFactor);				return result;	}	public float GetFloat(int whichAxis)	{		return Get(whichAxis);	}	/*		public Object clone()    {        try {            return super.clone();        }        catch (CloneNotSupportedException e) {            throw new InternalError();        }    }    */		public void Set(Location3D location)	{		x = location.GetFloat(Location3D.X_AXIS);		y = location.GetFloat(Location3D.Y_AXIS);		z = location.GetFloat(Location3D.Z_AXIS);	}		 public void Set(float value, int axis)	 {		switch (axis)		{			case FloatPoint.X:				x = value;				break;			case FloatPoint.Y:				y = value;				break;			case FloatPoint.Z:				z = value;				break;			default :				NeuroSynchUtil.ErrorMessage("Index out of range FloatPoint.Set(value,index)", NeuroSynchUtil.kNoDlog);				break;				}	 }	 public float Get(int index)	 {	 	float result;		switch (index)		{			case FloatPoint.X:				result = x;				break;			case FloatPoint.Y:				result = y;				break;			case FloatPoint.Z:				result = z;				break;			default :				NeuroSynchUtil.ErrorMessage("Index out of range FloatPoint.Get(index)", NeuroSynchUtil.kNoDlog);				result = 1;				break;				}				return result;	}  }