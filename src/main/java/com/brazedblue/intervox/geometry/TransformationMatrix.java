package com.brazedblue.intervox.geometry;// import javax.vecmath.*;import java.util.*;import com.brazedblue.intervox.data.*;import com.brazedblue.intervox.util.Debug;import com.brazedblue.intervox.util.NeuroSynchUtil;import com.brazedblue.intervox.registration.*;public class TransformationMatrix  implements java.io.Serializable { 	Matrix3							fRotationMatrix = new Matrix3();	Matrix3							fInverseRotationMatrix = new Matrix3();	ThreeDVector					fTranslationVector = new ThreeDVector();			boolean							fCanTransform = false;	boolean 						fCanUseReferenceFrame = false;	float							fCalculatedAccuracy = Float.MAX_VALUE;	// 0 to maxValue, 0 is exactly accurate	RegistrationConst[]				fReferencePoints = null;		transient	ReferenceMatrix 	fReferenceMatrix = null;		static int CENTROID_COUNT = 0;	// for debugging		static final long serialVersionUID =  75888601012553277L;		public TransformationMatrix() 	{	}		public boolean CanUseReferenceFrame()	{		return fCanUseReferenceFrame;	}		public TransformationMatrix(RegistrationConst[] registrations, boolean usingReference) 										throws ComputationException	{		CalculateMatrix(registrations, usingReference);	}			public void CalculateMatrix(RegistrationConst[] registrations, boolean useReferencePoints)										throws ComputationException	{		fCanUseReferenceFrame = RegistrationUseReference(registrations);	//	 just always check this		if (useReferencePoints && !fCanUseReferenceFrame)		{			NeuroSynchUtil.ErrorMessage("Can't use mobile with this point set.", NeuroSynchUtil.kShowDlog);			useReferencePoints = false;		}		if (registrations.length == 4)		{			CalculateFrom4Points(registrations, useReferencePoints);		}		else if (registrations.length == 3)		{			CalculateFrom3Points(registrations, useReferencePoints);		}		else if (registrations.length > 4)		{			CalculateUsingSVD(registrations);		}		fInverseRotationMatrix.Set(fRotationMatrix);		fInverseRotationMatrix.invert();	}		static public boolean RegistrationUseReference(RegistrationConst[] registrations)	{		boolean result = true;				for (int i = 0; i < registrations.length; i++)		{			if (!registrations[i].CanUseReference())			{				result = false;				break;			}		}				return result;	}		public void SetUsingReferenceFrame(boolean set)										throws ComputationException	{		CalculateMatrix(fReferencePoints, set);		fReferenceMatrix = set ? new ReferenceMatrix() : null;	} 		public String GetName()	{		String result = "";		for (int i = 0; i < fReferencePoints.length; i++)		{			if (i != 0)			{				result += ",";			}			result += fReferencePoints[i].GetName();		}				return result;	}		private boolean IsRegistrationUsedInCalculations(RegistrationConst registration)	{		boolean result = false;				for (int i = 0; i < fReferencePoints.length; i++)		{			if (fReferencePoints[i] == registration)			{				result = true;				break;			}		}				return result;	}		public void InverseTransformVector(ThreeDVector vector)	{		fInverseRotationMatrix.transform(vector);		if (fReferenceMatrix != null)		{			fReferenceMatrix.InverseTransformVector(vector);		}	}		public void InverseTransformPoint(FloatPoint point)	{	//	do reverse of TranslatePoint (should be TransformPoint)		point.Subtract(fTranslationVector);			fInverseRotationMatrix.transform(point);						if (fReferenceMatrix != null)		{			fReferenceMatrix.InverseTransformPoint(point);				}	}		static public Vector GenerateAllRegistrationSetsOf4(RegistrationConst[] registrations, boolean usingReference)	{		Vector result = new Vector();					//	create transformations from all possible sets of 4		for (int pt1 = 0; pt1 < registrations.length - 3; pt1++)		{			for (int pt2 = pt1 + 1; pt2 < registrations.length - 2; pt2++)			{				for (int pt3 = pt2 + 1; pt3 < registrations.length - 1; pt3++)				{					for (int pt4 = pt3 + 1; pt4 < registrations.length; pt4++)					{						try						{							RegistrationConst[] transformRegistrations = new Registration[4];							transformRegistrations[0] = registrations[pt1];							transformRegistrations[1] = registrations[pt2];							transformRegistrations[2] = registrations[pt3];							transformRegistrations[3] = registrations[pt4];													TransformationMatrix newTransform = new TransformationMatrix(transformRegistrations, usingReference);														if (newTransform.CanTransform())	// perhaps 4 points are in a plane							{								newTransform.CalculateAccuracy(registrations);																	//	insert matrices, most accurate first								int insertAt = result.size();																	// this could be optimized by a binary search								for (int i = 0; i < result.size(); i++)								{									TransformationMatrix transform = (TransformationMatrix)result.elementAt(i);																		if (transform.fCalculatedAccuracy > newTransform.fCalculatedAccuracy)									{										insertAt = i;										break;									}								}																result.insertElementAt(newTransform, insertAt);							}						}						catch (ComputationException e)						{							NeuroSynchUtil.ErrorMessage("Couldn't compute transformation: " + e.getMessage(), NeuroSynchUtil.kNoDlog);						}					}				}			}				}				return result;	}		static public Vector GenerateAllRegistrationSetsOf3(RegistrationConst[] registrations, boolean usingReference)	{		Vector result = new Vector();						//	create transformations from all possible sets of 3		for (int pt1 = 0; pt1 < registrations.length - 2; pt1++)		{			for (int pt2 = pt1 + 1; pt2 < registrations.length - 1; pt2++)			{				for (int pt3 = pt2 + 1; pt3 < registrations.length; pt3++)				{					try					{						RegistrationConst[] transformPairs = new RegistrationConst[3];						transformPairs[0] = registrations[pt1];						transformPairs[1] = registrations[pt2];						transformPairs[2] = registrations[pt3];											TransformationMatrix newTransform = new TransformationMatrix(transformPairs, usingReference);												if (newTransform.CanTransform())	// perhaps 4 points are in a plane						{							newTransform.CalculateAccuracy(registrations);															//	insert matrices, most accurate first							int insertAt = result.size();																// this could be optimized by a binary search							for (int i = 0; i < result.size(); i++)							{								TransformationMatrix transform = (TransformationMatrix)result.elementAt(i);																if (transform.fCalculatedAccuracy > newTransform.fCalculatedAccuracy)								{									insertAt = i;									break;								}							}														result.insertElementAt(newTransform, insertAt);						}					}					catch (ComputationException e)					{						NeuroSynchUtil.ErrorMessage("Couldn't compute transformation: " + e.getMessage(), NeuroSynchUtil.kNoDlog);					}				}			}				}				return result;	}		private void CalculateAccuracy(RegistrationConst[] registrations)										throws ComputationException	{		//	This is root mean square		float accuracy = 0;				RegistrationTransformer regTransformer = new RegistrationTransformer(this);		int pointsUsed = 0;				for (int i = 0; i < registrations.length; i++)		{			if (!IsRegistrationUsedInCalculations(registrations[i]))			{				float distance = regTransformer.GetDistance(registrations[i]);				accuracy += distance * distance;				pointsUsed++;			}		}				if (pointsUsed > 0)		{			accuracy /= pointsUsed;			accuracy = (float)Math.sqrt(accuracy);			 		}		fCalculatedAccuracy = accuracy;	}		public boolean CanTransform()	{		return fCanTransform;	}		public float GetAccuracy()	{		return fCalculatedAccuracy;	}		public void TranslatePoint(FloatPoint realPoint)	{		if (fReferenceMatrix != null)		{			fReferenceMatrix.TransformPoint(realPoint);				}		fRotationMatrix.transform(realPoint);						realPoint.add(fTranslationVector);	}		public void TransformVector(ThreeDVector vector)	{		if (fReferenceMatrix != null)		{			fReferenceMatrix.TransformVector(vector);		}		fRotationMatrix.transform(vector);	}		private void CalculateUsingSVD(RegistrationConst[] registrations)										throws ComputationException	{		final int 		kNumOfVectors = registrations.length;		ThreeDVector[]	realVectors = new ThreeDVector[kNumOfVectors];		ThreeDVector[]	virtualVectors = new ThreeDVector[kNumOfVectors];//		FloatPoint[] 	realPoints = GetRealPointsList(pointPairs, useReference);				for (int i = 0; i < kNumOfVectors; i++)		{			realVectors[i] = new ThreeDVector(registrations[i].GetLocation1());						virtualVectors[i] = new ThreeDVector(registrations[i].GetLocation2());		}				ThreeDVector realCentroid = ThreeDVector.CalculateCentroid(realVectors);		ThreeDVector virtualCentroid = ThreeDVector.CalculateCentroid(virtualVectors);		for (int i = 0; i < kNumOfVectors; i++)		{			realVectors[i].sub(realCentroid);			virtualVectors[i].sub(virtualCentroid);		}				final int kNumOfRows = 3;				ArbitraryFloatMatrix realMatrix = new ArbitraryFloatMatrix(kNumOfRows, kNumOfVectors);		ArbitraryFloatMatrix virtualMatrix = new ArbitraryFloatMatrix(kNumOfRows, kNumOfVectors);				for (int column = 1; column <= kNumOfVectors; column++)		{			ThreeDVector realVector = realVectors[column - 1];			ThreeDVector virtualVector = virtualVectors[column - 1];						for (int row = 1; row <= kNumOfRows; row++)			{				realMatrix.Set(row, column, realVector.Get(row - 1));				virtualMatrix.Set(row, column, virtualVector.Get(row - 1));			}		}						//	Algorithm taken from			// "Least-Squares Estimation of Transformation Parameters Between 2 Point Patterns"			//	Umeyama, Shinji			//  "IEEE Transactions on Pattern Analysis and Machine Intelligence", Vol. 13, No. 4, April 1991		realMatrix.Transpose();				ArbitraryFloatMatrix resultMatrix = new ArbitraryFloatMatrix(kNumOfRows, kNumOfRows);		virtualMatrix.Multiply(realMatrix, resultMatrix);		ArbitraryFloatMatrix uMatrix = new ArbitraryFloatMatrix(kNumOfRows, kNumOfRows);		ArbitraryFloatMatrix dMatrix = new ArbitraryFloatMatrix(kNumOfRows, kNumOfRows);		ArbitraryFloatMatrix vTransposeMatrix = new ArbitraryFloatMatrix(kNumOfRows, kNumOfRows);				resultMatrix.GetSVD(uMatrix, dMatrix, vTransposeMatrix);		ArbitraryFloatMatrix sMatrix = new ArbitraryFloatMatrix(kNumOfRows, kNumOfRows);		sMatrix.SetIdentity();				if (vTransposeMatrix.Determinant() * uMatrix.Determinant() == -1)		{			sMatrix.Set(3, 3, -1);		}							uMatrix.Multiply(sMatrix);		uMatrix.Multiply(vTransposeMatrix);				fRotationMatrix.Set(uMatrix);		float scaling;						float ratioSums = 0;		int count = 0;		for (int i = 0; i < kNumOfVectors; i++)		{			float realLength = realVectors[i].length();			if (realLength > 0.0)			{				ratioSums += virtualVectors[i].length() / realLength;				count++;			}		}				scaling = ratioSums / count;		fRotationMatrix.mul(scaling);		// calculate translation vector		fTranslationVector.set(virtualCentroid);				ThreeDVector translatedPoint = new ThreeDVector((Location3D)realCentroid);		fRotationMatrix.transform(translatedPoint);		// translate to virtual vector		translatedPoint.negate();		//	vector point to origin					// add vectors to get real origin -> virtual origin in virtual coordinates		fTranslationVector.add(translatedPoint);	//		fReferencePoints = registrations;				fCanTransform = true;	}/*			//	applies reference translation if appropriate, also sets fCanUseReferenceFrame	private FloatPoint[] GetRealPointsList(PointPair[] pointPairs, boolean useReference)	{		FloatPoint[] realPoints = new FloatPoint[pointPairs.length];				if (useReference)		{			fCanUseReferenceFrame = true;			FloatPoint refPoint = new FloatPoint();			Matrix3 invertedMatrix = new Matrix3();			for (int i = 0; i < pointPairs.length; i++)			{				ReferenceState state = pointPairs[i].GetReferenceState();								if (state != null)				{					if (i == 0)					{						fReferenceMatrix = new ReferenceMatrix(state);					}										refPoint.set(state.GetLocation());					realPoints[i] = new FloatPoint(pointPairs[i].GetRealPt());					realPoints[i].Subtract(refPoint);	//	vector in real space										invertedMatrix.Set(state.GetRotation());					invertedMatrix.invert();					invertedMatrix.transform(realPoints[i]);		//	point in sensor space				}				else				{					useReference = false;										break;				}						}				}				if (!useReference)		{				fReferenceMatrix = null;			fCanUseReferenceFrame = true;						for (int i = 0; i < pointPairs.length; i++)			{				realPoints[i] = pointPairs[i].GetRealPt();				ReferenceState state = pointPairs[i].GetReferenceState();								if (fCanUseReferenceFrame && pointPairs[i].GetReferenceState() == null)				{					fCanUseReferenceFrame = false;				}			}		}				return realPoints;	}*/		private void CalculateFrom4Points(RegistrationConst[] registrations, boolean useReference)										throws ComputationException	{		final int 		kNumOfVectors = 3;		ThreeDVector[]	realVectors = new ThreeDVector[kNumOfVectors];		ThreeDVector[]	virtualVectors = new ThreeDVector[kNumOfVectors];//		FloatPoint[] realPoints = GetRealPointsList(pointPairs, useReference);		for (int i = 0; i < kNumOfVectors; i++)		{			realVectors[i] = new ThreeDVector(registrations[i + 1].GetLocation1());			virtualVectors[i] = new ThreeDVector(registrations[i + 1].GetLocation2());		}				ThreeDVector realCentroid = ThreeDVector.CalculateCentroid(realVectors);		ThreeDVector virtualCentroid = ThreeDVector.CalculateCentroid(virtualVectors);				FloatPoint pt1ZeroPt = new FloatPoint(registrations[0].GetLocation1());		FloatPoint pt2ZeroPt = new FloatPoint(registrations[0].GetLocation2());				for (int i = 0; i < kNumOfVectors; i++)		{			realVectors[i].sub(pt1ZeroPt);			virtualVectors[i].sub(pt2ZeroPt);					}						Matrix3 realMatrix = new Matrix3(realVectors[0].Get(FloatPoint.X), realVectors[1].Get(FloatPoint.X), realVectors[2].Get(FloatPoint.X),										realVectors[0].Get(FloatPoint.Y), realVectors[1].Get(FloatPoint.Y), realVectors[2].Get(FloatPoint.Y),										realVectors[0].Get(FloatPoint.Z), realVectors[1].Get(FloatPoint.Z), realVectors[2].Get(FloatPoint.Z));				Matrix3 virtualMatrix = new Matrix3(virtualVectors[0].Get(FloatPoint.X), virtualVectors[1].Get(FloatPoint.X), virtualVectors[2].Get(FloatPoint.X),										virtualVectors[0].Get(FloatPoint.Y), virtualVectors[1].Get(FloatPoint.Y), virtualVectors[2].Get(FloatPoint.Y),										virtualVectors[0].Get(FloatPoint.Z), virtualVectors[1].Get(FloatPoint.Z), virtualVectors[2].Get(FloatPoint.Z));					fReferencePoints = registrations;				if (realMatrix.determinant() != 0.0 && virtualMatrix.determinant() != 0.0)		{			realMatrix.invert();				virtualMatrix.mul(realMatrix);				fRotationMatrix = new Matrix3(virtualMatrix);						fTranslationVector.set(virtualCentroid);						fRotationMatrix.transform(realCentroid);		// translate to virtual vector			realCentroid.negate();		//	vector point to origin						// add vectors to get real origin -> virtual origin in virtual coordinates			fTranslationVector.add(realCentroid);	//					fCanTransform = true;		}	}		public void SetCurrentReference(Matrix3 rotation, FloatPoint location)	{		if (fReferenceMatrix != null)		{			fReferenceMatrix.SetCurrentReference(rotation, location);				}	}		public void SetCurrentReference(ReferenceState state)	{		SetCurrentReference(state.GetRotation(), state.GetLocation());	}	private void CalculateFrom3Points(RegistrationConst[] registrations, boolean useReference)										throws ComputationException	{		final int 		kNumOfVectors = 3;		ThreeDVector[]	realVectors = new ThreeDVector[kNumOfVectors];		ThreeDVector[]	virtualVectors = new ThreeDVector[kNumOfVectors];//		FloatPoint[] realPoints = GetRealPointsList(pointPairs, useReference);		for (int i = 0; i < kNumOfVectors; i++)		{			realVectors[i] = new ThreeDVector(registrations[i].GetLocation1());			virtualVectors[i] = new ThreeDVector(registrations[i].GetLocation2());		}				ThreeDVector realCentroid = ThreeDVector.CalculateCentroid(realVectors);		ThreeDVector virtualCentroid = ThreeDVector.CalculateCentroid(virtualVectors);		for (int i = 0; i < kNumOfVectors - 1; i++)		{			realVectors[i].sub(realVectors[kNumOfVectors- 1]);			virtualVectors[i].sub(virtualVectors[kNumOfVectors- 1]);		}				// 3rd vector is the cross product		realVectors[2] = new ThreeDVector();		realVectors[2].cross(realVectors[0], realVectors[1]);					//	scale the cross product length to the average of the 2 vector lengths		realVectors[2].scale((realVectors[0].length() + realVectors[1].length()) / realVectors[2].length() * 2);				virtualVectors[2] = new ThreeDVector();		virtualVectors[2].cross(virtualVectors[0], virtualVectors[1]);					//	scale the cross product length to the average of the 2 vector lengths		virtualVectors[2].scale((virtualVectors[0].length() + virtualVectors[1].length()) / virtualVectors[2].length() * 2);		Matrix3 realMatrix = new Matrix3(realVectors[0].Get(FloatPoint.X), realVectors[1].Get(FloatPoint.X), realVectors[2].Get(FloatPoint.X),										realVectors[0].Get(FloatPoint.Y), realVectors[1].Get(FloatPoint.Y), realVectors[2].Get(FloatPoint.Y),										realVectors[0].Get(FloatPoint.Z), realVectors[1].Get(FloatPoint.Z), realVectors[2].Get(FloatPoint.Z));				Matrix3 virtualMatrix = new Matrix3(virtualVectors[0].Get(FloatPoint.X), virtualVectors[1].Get(FloatPoint.X), virtualVectors[2].Get(FloatPoint.X),										virtualVectors[0].Get(FloatPoint.Y), virtualVectors[1].Get(FloatPoint.Y), virtualVectors[2].Get(FloatPoint.Y),										virtualVectors[0].Get(FloatPoint.Z), virtualVectors[1].Get(FloatPoint.Z), virtualVectors[2].Get(FloatPoint.Z));					fReferencePoints = registrations;				if (realMatrix.determinant() != 0.0 && virtualMatrix.determinant() != 0.0)		{			realMatrix.invert();				virtualMatrix.mul(realMatrix);				fRotationMatrix = new Matrix3(virtualMatrix);									fTranslationVector.set(virtualCentroid);						fRotationMatrix.transform(realCentroid);		// translate to virtual vector			realCentroid.negate();		//	vector point to origin						// add vectors to get real origin -> virtual origin in virtual coordinates			fTranslationVector.add(realCentroid);	//						fCanTransform = true;		}	}			public void DebugDump()	{		if (Debug.fgDebugging)		{			System.out.println("Number of reference pt: " + fReferencePoints.length);						fRotationMatrix.DebugDump("Rotation matrix");			System.out.println("Translation vector" + fTranslationVector.toString());					}	}}