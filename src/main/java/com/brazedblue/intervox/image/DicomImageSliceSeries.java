package com.brazedblue.intervox.image;import com.brazedblue.intervox.dicom.*;import com.brazedblue.intervox.display.ProgressBroadcaster;import com.brazedblue.intervox.display.ProgressCancelledException;import com.brazedblue.intervox.file.*;import com.brazedblue.intervox.geometry.*;import com.brazedblue.intervox.util.*;import java.io.*;import java.util.*;public class DicomImageSliceSeries extends ImageSliceSeries implements DicomImageReceiver {  static final long serialVersionUID = 644908636525873607L;  private String fPatientName = null;  private String fSeriesID = null;  Date fSeriesDate = null;  private SingleSpaceID fSpaceID;  // for anonymize  //	private boolean 		fSeriesNameSet;  static int gAnonymousCount = 1;  private int fAnonymousID = gAnonymousCount;  public DicomImageSliceSeries() {    gAnonymousCount = gAnonymousCount + 1;  }  //	this is a hack  private boolean IsMRIModality(DicomImageDataSet dataSet) {    return "MR".equals(dataSet.GetModality());  }  public boolean AddDataSet(DicomImageDataSet dataSet, int resolution) throws IOException {    boolean added = false;    if (IsSameSeries(dataSet)) {      int width = dataSet.GetIntValue(DicomImageDataSet.kImageWidthTag);      int height = dataSet.GetIntValue(DicomImageDataSet.kImageHeightTag);      int bitDepth = dataSet.GetIntValue(DicomImageDataSet.kBitsAllocatedTag);      if (fHistogram == null) {        int maxValue = 2 << bitDepth;        fHistogram = new Histogram(maxValue, maxValue);      }      byte[] pixelData = dataSet.GetByteArray(DicomImageDataSet.kPixelDataTag);      int bytesAllocated = bitDepth / 8;      ThreeDVector imagePos = dataSet.GetPatientImagePosition();      if (!IsMRIModality(dataSet)) {        int highBit = dataSet.GetIntValue(DicomImageDataSet.kHighBitTag);        int bitsStored = dataSet.GetIntValue(DicomImageDataSet.kBitsStoredTag);        AdjustForBitsStoredAndHighBit(pixelData, bitDepth, bitsStored, highBit);      }      AddPixels(pixelData, bytesAllocated, width, height, imagePos, resolution);      float coordSize = dataSet.GetPixelSpacing() * resolution;      float sliceWidth = dataSet.GetSliceWidth();      SetSliceThickness(sliceWidth / coordSize);      added = true;      if (fRowVector == null) {        try {          ThreeDVector row = new ThreeDVector();          ThreeDVector column = new ThreeDVector();          dataSet.GetPatientOrientationVectors(row, column);          fRowVector = row;          fColumnVector = column;        } catch (IOException e) {          NeuroSynchUtil.ErrorMessage(              "Couldn't set patient vectors. " + e.getMessage(), NeuroSynchUtil.kNoDlog);        }      }      if (fSeriesDate == null) {        fSeriesDate = dataSet.GetSeriesDateAndTime();        //	put it here so it's only done once        if (fSpaceID != null) {          fSpaceID.SetUnit(new FloatUnit(coordSize * Unit.MILLIMETER));        }      }      if (fPatientName == null) {        fPatientName = dataSet.GetPatientName();      }    }    return added;  }  public SingleSpaceID GetSpaceID() {    return fSpaceID;  }  /*  	public void AdjustToStandardOrientation(ProgressBroadcaster progress) throws IOException  	{  		if (GetSliceThickness() != 1)  		{  			InterpolateToCubicVoxels(progress);  		}  		if (fColumnVector == null && fRowVector == null)  		{  			return;  		}  		ValidateOrientationVectors();  		if (fRowVector.x == 0 && fColumnVector.x == 0)  		{  				// sagittal  			if (fRowVector.y == 0)  			{  				FlipRowsAndColumns(progress, false);  			}  			if (fRowVector.y == -1)	//	 this should probably be 1  			{  				FlipLeftRight(progress, false);  			}  			if (fColumnVector.z == 1)  			{  				FlipTopBottom(progress);  			}  			if (fRowVector.x != 0 ||  				fRowVector.y != 1 ||  				fRowVector.z != 0 ||  				fColumnVector.x != 0 ||  				fColumnVector.y != 0 ||  				fColumnVector.z != -1 )  			{  				NeuroSynchUtil.ErrorMessage("Unable to adjust image orientation. row- " +  							fRowVector.toString() + ", column- " + fColumnVector.toString(),  							NeuroSynchUtil.kNoDlog);  				throw new IOException("Unable to adjust image orientation.");  			}  			RotateToCoronal(OrthoImageSetController.kSagittal, progress);  		}  		else if (fRowVector.z == 0 && fColumnVector.z == 0)  		{  				// axial  			if (fRowVector.x == 0)  			{  				FlipRowsAndColumns(progress);  			}  			if (fRowVector.x == -1)  			{  				FlipLeftRight(progress);  			}  			if (fColumnVector.y == -1)  			{  				FlipTopBottom(progress);  			}  			if (fRowVector.x != 1 ||  				fRowVector.y != 0 ||  				fRowVector.z != 0 ||  				fColumnVector.x != 0 ||  				fColumnVector.y != 1 ||  				fColumnVector.z != 0 )  			{  				NeuroSynchUtil.ErrorMessage("Unable to adjust image orientation. row- " +  							fRowVector.toString() + ", column- " + fColumnVector.toString(),  							NeuroSynchUtil.kNoDlog);  				throw new IOException("Unable to adjust image orientation.");  			}  			RotateToCoronal(OrthoImageSetController.kAxial, progress);  		}  		else // coronal  		{  				// sagittal  			if (fRowVector.x == 0)  			{  				FlipRowsAndColumns(progress);  			}  			if (fRowVector.x == -1)	//	 this should probably be 1  			{  				FlipLeftRight(progress);  			}  			if (fColumnVector.z == 1)  			{  				FlipTopBottom(progress);  			}  			if (fRowVector.x != 1 ||  				fRowVector.y != 0 ||  				fRowVector.z != 0 ||  				fColumnVector.x != 0 ||  				fColumnVector.y != 0 ||  				fColumnVector.z != -1 )  			{  				NeuroSynchUtil.ErrorMessage("Unable to adjust image orientation. row- " +  							fRowVector.toString() + ", column- " + fColumnVector.toString(),  							NeuroSynchUtil.kNoDlog);  				throw new IOException("Unable to adjust image orientation.");  			}  		}  	}  /*  	public float GetCoordSize()  	{  		return fCoordSize;  	} */  protected void SetSeriesID(String seriesID) {    if (Debug.fgDebugging && (fSeriesID != null || seriesID == null)) {      Debug.PrintStackTrace("fSeriesID: " + fSeriesID + ",seriesID: " + seriesID);    }    fSeriesID = seriesID;  }  public boolean IsSameSeries(DicomImageDataSet dataSet) {    boolean result = true;    String seriesID = dataSet.GetSeriesID();    if (seriesID != null) {      if (fSeriesID != null) {        result = fSeriesID.equals(seriesID);      } else {        SetSeriesID(seriesID);      }    }    return result;  }  public void AdjustForBitsStoredAndHighBit(      byte[] pixelData, int bitsAllocated, int bitsStored, int highBit) {    if (bitsAllocated != bitsStored || (bitsStored > highBit + 1)) {      if ((bitsAllocated % 8 == 0)          && bitsAllocated >= bitsStored          && highBit < bitsStored) // 	valid data      {        if ((bitsAllocated - bitsStored < 8) && (bitsStored - highBit == 1)) {          int maskShift = bitsAllocated - highBit;          byte mask = (byte) (0xFF >> maskShift);          byte negativeBit = (byte) 0x80;          byte highBitMask = (byte) (negativeBit >> (bitsAllocated - highBit - 1));          int bytesAllocated = bitsAllocated / 8;          for (int i = 0; i < pixelData.length; i += bytesAllocated) {            byte byteValue = pixelData[i];            boolean negative = (byteValue & highBitMask) != 0;            byteValue &= mask;            if (negative) {              byteValue |= negativeBit;            }            pixelData[i] = byteValue;          }        } else {          NeuroSynchUtil.ErrorMessage(              "Invalid values (bitsAllocated- "                  + bitsAllocated                  + "), (bitsStored- "                  + bitsStored                  + "), (highBit- "                  + highBit                  + ")",              NeuroSynchUtil.kNoDlog);        }      } else {        NeuroSynchUtil.ErrorMessage(            "Invalid values (bitsAllocated- "                + bitsAllocated                + "), (bitsStored- "                + bitsStored                + "), (highBit- "                + highBit                + ")",            NeuroSynchUtil.kNoDlog);      }    }  }  public String GetSeriesName() {    return fSpaceID.GetName();  }  /*  	public Object clone()      {          try {              ImageSeries copy = (DicomImageSeries)super.clone();  			if (fRowVector != null)  			{  				copy.fRowVector = (ThreeDVector)fRowVector.clone();  			}  			if (fColumnVector != null)  			{  				copy.fColumnVector = (ThreeDVector)fColumnVector.clone();  			}  			if (fImagePositionsTable != null)  			{  				copy.fImagePositionsTable = (ThreeDVectorTable)fImagePositionsTable.clone();  			}  			return copy;          }          catch (CloneNotSupportedException e) {              throw new InternalError();          }  	}  */  /*	private void FlipRowsAndColumns(ProgressBroadcaster progress)  	{  		ThreeDVector savedRow = new ThreeDVector(fRowVector);  		fRowVector.set(fColumnVector);  		fColumnVector.set(savedRow);  		super.FlipRowsAndColumns(progress);  	}  */  /*    public void RotateToCoronal(int fromAxis, ProgressBroadcaster progress)  	{  		if (GetCoordsPerImage() != 1)  		{  			NeuroSynchUtil.ErrorMessage("Attempting to rotate non-cubic voxels", NeuroSynchUtil.kShowDlog);  			return;  		}  		switch (fromAxis)  		{  			case OrthoImageSetController.kAxial :  			case OrthoImageSetController.kSagittal :  				{  					super.RotateToCoronal(fromAxis, progress);  					fRowVector.set(1, 0, 0);  					fColumnVector.set(0, 0, -1);  				}  				break;  			default :  				neurosynch.util.NeuroSynchUtil.ErrorMessage("Invalid access in ImageSeries.RotateToSagittal", NeuroSynchUtil.kNoDlog);  				break;  		}      }  */  /*  	private void ValidateOrientationVectors() throws IOException  	{  		String errorString = "Invalid orientation vectors.";  		if (fRowVector == null || fColumnVector == null)  		{  			throw new IOException(errorString);  		}  		RoundOrientationVectors();  		int rowAxis = -1;  		int columnAxis = -1;  		for (int axis = FloatPoint.X; axis <= FloatPoint.Z; axis++)  		{  			if (fRowVector.Get(axis) == 1 || fRowVector.Get(axis) == -1)  			{  				if (rowAxis != -1)  				{  					throw new IOException(errorString);  				}  				rowAxis = axis;  			}  			else if (fRowVector.Get(axis) != 0)  			{  				throw new IOException(errorString);  			}  			if (fColumnVector.Get(axis) == 1 || fColumnVector.Get(axis) == -1)  			{  				if (columnAxis != -1)  				{  					throw new IOException(errorString);  				}  				columnAxis = axis;  			}  			else if (fColumnVector.Get(axis) != 0)  			{  				throw new IOException(errorString);  			}  		}  		if (rowAxis == -1 || columnAxis == -1 || rowAxis == columnAxis)  		{  			throw new IOException(errorString);  		}  	}  */  /*  public void Flip(int whichAxis, ProgressBroadcaster progress)  {  	super.Flip(whichAxis, progress);  	if (whichAxis == FloatPoint.Y)	// top <-> bottom  	{  		fColumnVector.negate();  	}  	else if (whichAxis == FloatPoint.X) // left <-> right  	{  		fRowVector.negate();  	}  } */  /*  	public void AddPixelData(PixelData data, ThreeDVector imagePos)  	{  		fPixels.addElement(data);  		if (fImagePositionsTable != null && imagePos != null)  		{  			fImagePositionsTable.Insert(imagePos, data);  		}  	}  */  public String GetName() // 	 Image3DField override      {    return GetSeriesName();  }  public void FinishReceiving(ProgressBroadcaster broadcaster) throws IOException {    try {      ComputeHistogram(broadcaster);      InterpolateToCubicVoxels(broadcaster);      AdjustToStandardOrientation(broadcaster);      fComplete = true;      fSeriesID = String.format("%d", fAnonymousID);      fSpaceID = SingleSpaceID.NewDicomSpaceID(fSeriesID);      fSpaceID.SetName(String.format("John Doe %d", fAnonymousID));    } catch (ProgressCancelledException e) {      throw new IOException("User cancelled");    }  }}