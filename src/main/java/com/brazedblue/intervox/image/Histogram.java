package com.brazedblue.intervox.image;import com.brazedblue.intervox.util.NeuroSynchUtil;public class Histogram implements java.io.Serializable { 	private int 		fHighestValue = -1;	private int[]		fHistogramArray;	boolean				fExcludeZero = true;	private int 		fValuesPerEntry = 1;	private int			fLowEntry = 0;		static final long serialVersionUID = 7350787436998295824L;    public Histogram(int maxValue, int numOfEntries) 	{		fHistogramArray = new int[numOfEntries];				SetNumOfEntries(numOfEntries);    }		public void SetLowEntry(int lowEntry)	{		fLowEntry = lowEntry;	}		public int GetMaxValue()	{		return GetValueForIndex(fHistogramArray.length - 1);	}	void SetNumOfEntries(int numOfEntries)	{		if (fHistogramArray != null && fHistogramArray.length > 0)		{			fValuesPerEntry = numOfEntries / fHistogramArray.length;						if (fValuesPerEntry != 0)			{				if (numOfEntries % fHistogramArray.length != 0)				{					fValuesPerEntry++;				}			}			else			{				fValuesPerEntry = 1;			}		}		else		{			fValuesPerEntry = 1;		}	}	/*		// is this called?	protected void ChangeSize(int newSize)	{		if (newSize != fHistogramArray.length)		{			int[] newArray = new int[newSize];						int copyLength = newSize < fHistogramArray.length ? newSize : fHistogramArray.length;			System.arraycopy(fHistogramArray, 0, newArray, 0, copyLength);						fHistogramArray = newArray;		}	}*/		public Object clone()    {        try {			Histogram copy = (Histogram)super.clone();			copy.fHistogramArray= (int[])copy.clone();			            return copy;        }        catch (CloneNotSupportedException e) {            throw new InternalError();        }    }		// I don't think this is called/*	public int GetCutOff(float fraction)	{		int result = 1;		if (fraction >= 0 && fraction <= 1)		{			int totalCount = 0;			int size = fHistogramArray.length;			for (int i = 0; i < size; i++)			{				totalCount += fHistogramArray[i];			}						int cutoffCount = (int)(totalCount * fraction);						totalCount = 0;			for (int i = 0; i < size; i++)			{				totalCount += fHistogramArray[i];								if (totalCount > cutoffCount)				{					result = i * fValuesPerEntry + fLowEntry;					break;				}			}					}		else		{			neurosynch.util.NeuroSynchUtil.ErrorMessage("fraction out of range in Histogram.GetCutOff(fraction).", false);		}		return result;	}*/		public Histogram GetContractedCopy(int newSize)	{				Histogram result = new Histogram(newSize);				float factor = (float)GetSize() / (float)newSize;					//	implement this part in clone method?		result.fValuesPerEntry = (int)(fValuesPerEntry * factor);		result.fExcludeZero = fExcludeZero;		result.fLowEntry = fLowEntry;				for (int i = 0; i < fHistogramArray.length; i++)		{			int index = (int)(i / factor);									result.fHistogramArray[index] += fHistogramArray[i];		}				return result;	}		public Histogram(int numOfEntries) 	{		this(numOfEntries, numOfEntries);    }	public void Set(PixelData data, boolean calculateScale)	{		Clear();		Add(data, calculateScale);	}		public void Clear()	{		int size = fHistogramArray.length;		for (int i = 0; i < size; i++)		{			fHistogramArray[i] = 0;		}	}		int GetIndexForValue(int value)	{		int index = (value - fLowEntry)  / fValuesPerEntry;		return NeuroSynchUtil.Limit(index, 0, fHistogramArray.length - 1);	}	int GetValueForIndex(int index)	{		return index * fValuesPerEntry + fLowEntry;	}			public void Add(PixelData data, boolean calculateScale)	{		int width = data.GetWidth();		int height = data.GetHeight();				int histoSize = fHistogramArray.length;		int index;		int value;				for (int y = 0; y < height; y++)		{			for (int x = 0; x < width; x++)			{				value = data.GetPixelValue(x, y);				index = GetIndexForValue(value);				fHistogramArray[index]++;			}		}				if (fExcludeZero)		{			fHistogramArray[0] = 0;		}				if (calculateScale)		{			CalculateScale();		}		else		{			fHighestValue = -1;		// this value has become invalid		}	}		public void ScaleTo(int value)	{		if (fHighestValue == -1)		{			CalculateScale();		}				if (fHighestValue > 0 && value != fHighestValue)		{			float adjustment = (float)value/(float)fHighestValue;			int size = fHistogramArray.length;			for (int i = 0; i < size; i++)			{				fHistogramArray[i] *= adjustment;								fHistogramArray[i] = Math.min(fHistogramArray[i], value);			}			fHighestValue = value;		}			}		public void CalculateScale()	{		fHighestValue = 0;		int size = fHistogramArray.length;				for (int i = 0; i < size; i++)		{			int value = fHistogramArray[i];						if (value > 0)			{				int adjustedValue = (int)Math.sqrt(value);				fHistogramArray[i] = adjustedValue;								if (adjustedValue > fHighestValue)				{					fHighestValue = adjustedValue;				}			}		}	}		public int GetCountForIndex(int index)	{		return fHistogramArray[index];	}		public int GetSize()	{		return fHistogramArray.length;	}		public int GetScale()	{		if (fHighestValue == -1)		{			CalculateScale();		}				return fHighestValue;	} }