package com.brazedblue.intervox.image;import com.brazedblue.intervox.data.*;import com.brazedblue.intervox.dicom.*;import com.brazedblue.intervox.display.*;import com.brazedblue.intervox.file.*;import com.brazedblue.intervox.geometry.*;import com.brazedblue.intervox.util.*;import java.awt.*;import java.awt.image.*;import java.io.*;import java.util.*;public class ImageSliceSeries implements Serializable, Cloneable, Image3DField {  private Vector fPixels = new Vector();  private float fSliceThickness = 1;  private int fMaxValue = Integer.MIN_VALUE;  private int fMinValue = Integer.MAX_VALUE;  protected Histogram fHistogram;  private final int kMaxByteValue = 255;  protected ThreeDVector fRowVector;  protected ThreeDVector fColumnVector;  protected transient ThreeDVectorTable fImagePositionsTable = new ThreeDVectorTable();  protected transient boolean fComplete = true;  static final int kVersionNum = 1;  static final long serialVersionUID = -6122016886493700453L;  public ImageSliceSeries() {}  public void ComputeHistogram(ProgressBroadcaster progress) throws ProgressCancelledException {    if (fMaxValue == Integer.MIN_VALUE) {      ComputeMaxValue();    }    if (fMinValue != 0) {      AdjustMinValueToZero(progress);    }    if (fMaxValue < 0) {      fMaxValue = 0;      NeuroSynchUtil.ErrorMessage(          "Negative computed max value in ImageSeries.ComputeHistogram", NeuroSynchUtil.kNoDlog);    }    fHistogram = new Histogram(fMaxValue);    int size = fPixels.size();    if (progress != null) {      progress.Start("Computing Histogram", 0, size - 1);    }    for (int i = 0; i < size; i++) {      if (progress != null) {        progress.UpdateCurrentValue(Integer.toString(i), i);      }      PixelData data = (PixelData) fPixels.elementAt(i);      fHistogram.Add(data, false);    }    fHistogram.CalculateScale();  }  protected void ComputeMaxValue() {    fMaxValue = Integer.MIN_VALUE;    int size = fPixels.size();    for (int i = 0; i < size; i++) {      PixelData data = (PixelData) fPixels.elementAt(i);      int maxValue = data.GetMaxValue();      if (maxValue > fMaxValue) {        fMaxValue = maxValue;      }    }  }  /*		problem here about subclasses  	public void Set(ImageSeries otherSeries)  	{  //		fCoordSize = otherSeries.fCoordSize;  //		fSliceWidth = otherSeries.fSliceWidth;  		fHistogram = otherSeries.fHistogram;  		fMaxValue = otherSeries.fMaxValue;  		fPixels = otherSeries.fPixels;  	}  */  private float GetSliceThickness() {    return fSliceThickness;  }  public Histogram GetHistogram() {    fHistogram.GetScale(); // forces a calculation of scale, if not yet calculated    return fHistogram;  }  public Object clone() {    try {      ImageSliceSeries copy = (ImageSliceSeries) super.clone();      copy.fPixels = (Vector) fPixels.clone();      if (fHistogram != null) {        copy.fHistogram = (Histogram) fHistogram.clone();      }      return copy;    } catch (CloneNotSupportedException e) {      throw new InternalError();    }  }  public int GetMaxValue() {    return fMaxValue;  }  public String GetName() // 	 Image3DField override      {    return "Image Series";  }  private void OrderPixels() throws IOException {    if (fImagePositionsTable != null && fImagePositionsTable.size() > 0) {      if (fImagePositionsTable.size() != fPixels.size()) {        NeuroSynchUtil.ErrorMessage(            "fImagePositionsTable.size() "                + fImagePositionsTable.size()                + " != fPixels.size()"                + fPixels.size(),            NeuroSynchUtil.kNoDlog);        if (fPixels.size() < fImagePositionsTable.size()) {          NeuroSynchUtil.ErrorMessage(              "fImagePositionsTable.size() "                  + fImagePositionsTable.size()                  + " != fPixels.size()"                  + fPixels.size(),              NeuroSynchUtil.kShowDlog);          return;        }      }      int sliceAxis = GetSliceDifferenceAxis();      float imageDifference = 0;      fPixels.removeAllElements();      int size = fImagePositionsTable.size();      ThreeDVectorTable.ThreeDVectorEntry lastEntry = null;      for (int i = 0; i < size; i++) {        int index = (sliceAxis == FloatPoint.X) ? size - i - 1 : i;        ThreeDVectorTable.ThreeDVectorEntry entry =            (ThreeDVectorTable.ThreeDVectorEntry) fImagePositionsTable.elementAt(index);        if (lastEntry == null) {          // "fObject" should be PixelData, cast to make sure          fPixels.addElement((PixelData) entry.fObject);        } else {          boolean wasError = false;          if (imageDifference == 0) {            imageDifference = entry.fPoint.Get(sliceAxis) - lastEntry.fPoint.Get(sliceAxis);            if (imageDifference == 0) {              wasError = true;            }          } else {            float currentDifference = entry.fPoint.Get(sliceAxis) - lastEntry.fPoint.Get(sliceAxis);            float variance = Math.abs((currentDifference - imageDifference) / imageDifference);            if (variance > .01) {              wasError = true;            }          }          if (wasError) {            //							NeuroSynchUtil.ErrorMessage("Discrepencies in the slice spacing have been            // encountered." +            //											"Between images " + Integer.toString(i-1) + " and " + Integer.toString(i) +            // ".",            //											NeuroSynchUtil.kShowDlog);            throw new DicomException(                "Discrepencies in the slice spacing have been encountered."                    + "Between images "                    + Integer.toString(i - 1)                    + " and "                    + Integer.toString(i)                    + ".");          }          fPixels.addElement((PixelData) entry.fObject);        }        lastEntry = entry;      }      /*			ignores resolution factor      			if (imageDifference != 0)      			{      				SetSliceThickness(Math.abs(imageDifference));      			}      */    }  }  private int GetSliceDifferenceAxis() throws IOException {    ValidateOrientationVectors();    int result = -1;    for (int axis = FloatPoint.X; axis <= FloatPoint.Z; axis++) {      if (fColumnVector.Get(axis) == 0 && fRowVector.Get(axis) == 0) {        result = axis;        break;      }    }    if (result == -1) {      throw new DicomException("Problems with the image orientation vectors");    }    return result;  }  private void FlipRowsAndColumns(ProgressBroadcaster progress) throws ProgressCancelledException {    int numofSlices = fPixels.size();    if (progress != null) {      progress.Start("Flipping rows and columns", 0, numofSlices - 1);    }    for (int i = 0; i < numofSlices; i++) {      if (progress != null) {        progress.UpdateCurrentValue(Integer.toString(i), i);      }      PixelData pixels = (PixelData) fPixels.elementAt(i);      pixels.FlipRowsAndColumns();    }    ThreeDVector savedRow = new ThreeDVector((Location3D) fRowVector);    fRowVector.set(fColumnVector);    fColumnVector.set(savedRow);    /*		if (progress != null && callEnd)    {    	progress.End();    } */  }  private void FlipLeftRight(ProgressBroadcaster progress) throws ProgressCancelledException {    Flip(FloatPoint.X, progress);  }  private void FlipTopBottom(ProgressBroadcaster progress) throws ProgressCancelledException {    Flip(FloatPoint.Y, progress);  }  public void RotateToCoronal(int fromAxis, ProgressBroadcaster progress)      throws ProgressCancelledException {    if (GetSliceThickness() != 1) {      NeuroSynchUtil.ErrorMessage(          "Attempting to rotate non-cubic voxels", NeuroSynchUtil.kShowDlog);      return;    }    switch (fromAxis) {      case OrthoImageSetController.kAxial:      case OrthoImageSetController.kSagittal:        {          Vector newPixels = new Vector();          int max = MaxCoord(fromAxis);          if (progress != null) {            progress.Start(                ("Translating from "                    + (fromAxis == OrthoImageSetController.kAxial ? "axial" : "sagittal")),                0,                max - 1);          }          for (int i = 0; i < max; i++) {            if (progress != null) {              progress.UpdateCurrentValue(Integer.toString(i), i);            }            PixelData pixelData = PixelsAtCoord(i, fromAxis);            newPixels.insertElementAt(pixelData, 0);          }          /*          if (progress != null && callEnd)          {          	progress.End();          } */          fPixels = newPixels;          fRowVector.set(1, 0, 0);          fColumnVector.set(0, 0, -1);        }        break;      default:        NeuroSynchUtil.ErrorMessage(            "Invalid access in ImageSeries.RotateToSagittal", NeuroSynchUtil.kNoDlog);        break;    }  }  public void Flip(int whichAxis, ProgressBroadcaster progress) throws ProgressCancelledException {    Vector newPixels = new Vector();    int max = NumOfPixels();    if (progress != null) {      String flipType = "";      switch (whichAxis) {        case FloatPoint.Y:          flipType = "top <=> bottom";          break;        case FloatPoint.Z:          flipType = "front <-> back";          break;        case FloatPoint.X:          flipType = "left <-> right";          break;      }      progress.Start("Flipping image " + flipType, 0, max - 1);    }    for (int i = 0; i < max; i++) {      if (progress != null) {        progress.UpdateCurrentValue(Integer.toString(i), i);      }      PixelData pixelData = PixelsAtIndex(i);      if (whichAxis == FloatPoint.Y) // top <-> bottom      {        pixelData.FlipOnYAxis();      } else if (whichAxis == FloatPoint.X) // left <-> right      {        pixelData.FlipOnXAxis();      }      if (whichAxis == FloatPoint.Z) // front <-> back      {        newPixels.insertElementAt(pixelData, 0);      } else {        newPixels.addElement(pixelData);      }    }    fPixels = newPixels;    if (whichAxis == FloatPoint.Y) // top <-> bottom    {      fColumnVector.negate();    } else if (whichAxis == FloatPoint.X) // left <-> right    {      fRowVector.negate();    }    /*    if (progress != null && callEnd)    {    	progress.End();    } */  }  public void SetSliceThickness(float sliceThickness) {    fSliceThickness = sliceThickness;  }  int NumOfPixels() {    return fPixels.size();  }  boolean IsComplete() {    return fComplete;  }  public void InterpolateToCubicVoxels(ProgressBroadcaster progress)      throws IOException, ProgressCancelledException {    OrderPixels();    int numOfSlices = fPixels.size();    float sliceThickness = GetSliceThickness();    int maxZ = (int) (numOfSlices * sliceThickness);    progress.Start("Interpolating to cubic voxels", 0, maxZ);    NeuroSynchUtil.MyYield();    Vector newPixels = new Vector();    for (int i = 0; i < maxZ; i++) {      progress.UpdateCurrentValue("Image- " + i, i);      NeuroSynchUtil.MyYield();      float arrayIndex = i / sliceThickness;      int indexInt = (int) arrayIndex;      float remainder = arrayIndex - indexInt;      if (remainder < .1 || (indexInt == numOfSlices - 1)) {        PixelData pData = PixelsAtIndex(indexInt);        newPixels.addElement((PixelData) pData.clone());      } else if (remainder > .9) {        PixelData pData = PixelsAtIndex(indexInt + 1);        newPixels.addElement((PixelData) pData.clone());      } else {        PixelData pData1 = PixelsAtIndex(indexInt);        PixelData pData2 = PixelsAtIndex(indexInt + 1);        float oneMinusRemainder = 1 - remainder;        int width = pData1.GetWidth();        int height = pData1.GetHeight();        PixelData newData = pData1.NewDataObject(width, height);        for (int y = 0; y < height; y++) {          for (int x = 0; x < width; x++) {            int newValue =                (int)                    (oneMinusRemainder * pData1.GetPixelValue(x, y)                        + remainder * pData2.GetPixelValue(x, y));            newData.SetPixelValue(x, y, newValue);          }        }        newPixels.addElement(newData);      }    }    fPixels = newPixels;    SetSliceThickness(1);    System.gc(); // 	garbage collect  }  public ImageSliceSeries GetCopy() {    return (ImageSliceSeries) clone();  }  private PixelData PixelsAtIndex(int index) {    return (PixelData) fPixels.elementAt(index);  }  public void AddPixelData(PixelData data, ThreeDVector imagePos) {    fPixels.addElement(data);    if (fImagePositionsTable != null && imagePos != null) {      fImagePositionsTable.Insert(imagePos, data);    }    fComplete = false; // 	force post-processing  }  public SingleSpaceID GetSpaceID() {    return null;  }  public void AdjustMinValueToZero(ProgressBroadcaster progress) throws ProgressCancelledException {    if (fMinValue == Integer.MAX_VALUE) // if fMinValue hasn't been set, just set it to zero    {      fMinValue = 0;    }    int size = fPixels.size();    if (fMinValue != 0) {      if (progress != null) {        progress.Start("Adjusting to zero based gray scale", 0, size - 1);      }      for (int i = 0; i < size; i++) {        if (progress != null) {          progress.UpdateCurrentValue(Integer.toString(i), i);        }        PixelData data = (PixelData) fPixels.elementAt(i);        data.AdjustToUnsigned(fMinValue);      }      fMaxValue -= fMinValue;      fMinValue = 0;    }  }  public void AdjustToStandardOrientation(ProgressBroadcaster progress)      throws IOException, ProgressCancelledException {    if (GetSliceThickness() != 1) {      InterpolateToCubicVoxels(progress);    }    if (fColumnVector == null && fRowVector == null) {      return;    }    ValidateOrientationVectors();    if (fRowVector.x == 0 && fColumnVector.x == 0) {      // sagittal      if (fRowVector.y == 0) {        FlipRowsAndColumns(progress);      }      if (fRowVector.y == -1) // 	 this should probably be 1      {        FlipLeftRight(progress);      }      if (fColumnVector.z == 1) {        FlipTopBottom(progress);      }      if (fRowVector.x != 0          || fRowVector.y != 1          || fRowVector.z != 0          || fColumnVector.x != 0          || fColumnVector.y != 0          || fColumnVector.z != -1) {        NeuroSynchUtil.ErrorMessage(            "Unable to adjust image orientation. row- "                + fRowVector.toString()                + ", column- "                + fColumnVector.toString(),            NeuroSynchUtil.kNoDlog);        throw new IOException("Unable to adjust image orientation.");      }      RotateToCoronal(OrthoImageSetController.kSagittal, progress);    } else if (fRowVector.z == 0 && fColumnVector.z == 0) {      // axial      if (fRowVector.x == 0) {        FlipRowsAndColumns(progress);      }      if (fRowVector.x == -1) {        FlipLeftRight(progress);      }      if (fColumnVector.y == -1) {        FlipTopBottom(progress);      }      if (fRowVector.x != 1          || fRowVector.y != 0          || fRowVector.z != 0          || fColumnVector.x != 0          || fColumnVector.y != 1          || fColumnVector.z != 0) {        NeuroSynchUtil.ErrorMessage(            "Unable to adjust image orientation. row- "                + fRowVector.toString()                + ", column- "                + fColumnVector.toString(),            NeuroSynchUtil.kNoDlog);        throw new IOException("Unable to adjust image orientation.");      }      RotateToCoronal(OrthoImageSetController.kAxial, progress);    } else // coronal    {      // sagittal      if (fRowVector.x == 0) {        FlipRowsAndColumns(progress);      }      if (fRowVector.x == -1) // 	 this should probably be 1      {        FlipLeftRight(progress);      }      if (fColumnVector.z == 1) {        FlipTopBottom(progress);      }      if (fRowVector.x != 1          || fRowVector.y != 0          || fRowVector.z != 0          || fColumnVector.x != 0          || fColumnVector.y != 0          || fColumnVector.z != -1) {        NeuroSynchUtil.ErrorMessage(            "Unable to adjust image orientation. row- "                + fRowVector.toString()                + ", column- "                + fColumnVector.toString(),            NeuroSynchUtil.kNoDlog);        throw new IOException("Unable to adjust image orientation.");      }    }  }  protected PixelData AddPixels(      byte[] newPixels,      int pixelSize,      int newWidth,      int newHeight,      ThreeDVector imagePos,      int resolution) {    PixelData result = null;    if (newPixels.length != (newWidth * newHeight * pixelSize)) {      NeuroSynchUtil.ErrorMessage(          "ImageSeries.AddPixels: newPixels.length- "              + newPixels.length              + ", newWidth- "              + newWidth              + ", newHeight- "              + newHeight              + ", pixelSize- "              + pixelSize,          NeuroSynchUtil.kNoDlog);    }    if (newPixels.length / pixelSize >= (newWidth * newHeight)) {      if (pixelSize == 1) {        fMaxValue = kMaxByteValue;        fMinValue = 0;        result = PixelData.NewDataInstance(newWidth, newHeight, newPixels, resolution);        AddPixelData(result, imagePos);      } else if (pixelSize == 2) {        short[] pixels = new short[newHeight * newWidth];        for (int i = 0; i < pixels.length; i++) {          short pixelVal = 0;          int pixelStart = i * pixelSize;          for (int j = 0; j < pixelSize; j++) {            int value = newPixels[pixelStart + j] & 0xff;            pixelVal |= value << (8 * (pixelSize - j - 1));          }          if (Debug.fgDebugging && pixelVal < 0) {            int value = pixelVal;            int valueSquared = value * value;          }          fMaxValue = Math.max(fMaxValue, pixelVal);          fMinValue = Math.min(fMinValue, pixelVal);          pixels[i] = pixelVal;        }        result = PixelData.NewDataInstance(newWidth, newHeight, pixels, resolution);        AddPixelData(result, imagePos);      } else if (pixelSize < 4) {        NeuroSynchUtil.ErrorMessage(            "image pixel size is out of range- " + pixelSize, NeuroSynchUtil.kShowDlog);      }    } else {      NeuroSynchUtil.ErrorMessage("Adding pixels of different size", NeuroSynchUtil.kShowDlog);    }    return result;  }  public int MaxCoord(int axis) {    int result = 0;    if (NumOfPixels() > 0) {      switch (axis) {        case OrthoImageSetController.kSagittal:          {            PixelData pData = PixelsAtIndex(0);            result = pData.GetWidth() - 1;          }          break;        case OrthoImageSetController.kAxial:          PixelData pData = PixelsAtIndex(0);          result = pData.GetHeight() - 1;          break;        case OrthoImageSetController.kCoronal:          result = Math.round(fPixels.size() * GetSliceThickness()) - 1;          break;      }    }    return result;  }  public PixelData PixelsAtCoord(int coord, int axis) {    if (axis == OrthoImageSetController.kCoronal) {      return PixelsAtIndex(coord);    } else if (axis == OrthoImageSetController.kSagittal) {      PixelData firstPix = PixelsAtIndex(0);      int width = NumOfPixels();      int height = firstPix.GetHeight();      int rowWidth = firstPix.GetWidth();      PixelData result = firstPix.NewDataObject(width, height);      for (int x = 0; x < width; x++) {        PixelData pixData = PixelsAtIndex(x);        for (int y = 0; y < height; y++) {          result.SetPixelValue(width - x - 1, y, pixData.GetPixelValue(coord, y));        }      }      return result;    } else if (axis == OrthoImageSetController.kAxial) {      PixelData firstPix = PixelsAtIndex(0);      int height = NumOfPixels();      int width = firstPix.GetWidth();      PixelData result = firstPix.NewDataObject(width, height);      Object newPixels = result.GetPixels();      for (int i = 0; i < height; i++) {        PixelData pixData = PixelsAtIndex(height - i - 1);        Object fromPixels = pixData.GetPixels();        System.arraycopy(fromPixels, width * coord, newPixels, i * width, width);      }      return result;    }    return null;  }  private int IndexOf(PixelData pixels) {    return fPixels.indexOf(pixels);  }  public int CoordOf(PixelData pixels) {    int index = IndexOf(pixels);    return Math.round(index * GetSliceThickness());  }  private void ValidateOrientationVectors() throws IOException {    String errorString = "Invalid orientation vectors.";    if (fRowVector == null || fColumnVector == null) {      throw new IOException(errorString);    }    RoundOrientationVectors();    int rowAxis = -1;    int columnAxis = -1;    for (int axis = FloatPoint.X; axis <= FloatPoint.Z; axis++) {      if (fRowVector.Get(axis) == 1 || fRowVector.Get(axis) == -1) {        if (rowAxis != -1) {          throw new IOException(errorString);        }        rowAxis = axis;      } else if (fRowVector.Get(axis) != 0) {        throw new IOException(errorString);      }      if (fColumnVector.Get(axis) == 1 || fColumnVector.Get(axis) == -1) {        if (columnAxis != -1) {          throw new IOException(errorString);        }        columnAxis = axis;      } else if (fColumnVector.Get(axis) != 0) {        throw new IOException(errorString);      }    }    if (rowAxis == -1 || columnAxis == -1 || rowAxis == columnAxis) {      throw new IOException(errorString);    }  }  public PixelData GetSlicePixelData(      FloatPoint middlePoint, ThreeDVector xIncVector, ThreeDVector yIncVector, Dimension size) {    PixelData firstPix = PixelsAtIndex(0);    byte[] pixels = new byte[size.width * size.height];    int width = size.width;    int height = size.height;    PixelData result = firstPix.NewDataObject(width, height);    FloatPoint startPoint = new FloatPoint();    startPoint.Set(middlePoint, xIncVector, -width / 2);    FloatPoint rowPoint = new FloatPoint();    FloatPoint pixelPoint = new FloatPoint();    for (int y = 0; y < height; y++) {      pixelPoint.Set(startPoint, yIncVector, y);      for (int x = 0; x < width; x++) {        pixelPoint.Add(xIncVector);        result.SetPixelValue(x, y, GetPixelValue(pixelPoint));      }    }    return result;  }  int GetPixelValue(FloatPoint point) {    int result = 0;    int zValue = point.GetRoundedInt(FloatPoint.Z);    if (zValue >= 0 && zValue < fPixels.size()) {      PixelData data = (PixelData) fPixels.elementAt(zValue);      result =          data.GetPixelValue(point.GetRoundedInt(FloatPoint.X), point.GetRoundedInt(FloatPoint.Y));    }    return result;  }  private void RoundOrientationVectors() {    boolean round = false;    for (int i = FloatPoint.X; i <= FloatPoint.Y; i++) {      float value = fColumnVector.Get(i);      if (value != 0 && value != -1 && value != 1) {        round = true;        break;      }      value = fRowVector.Get(i);      if (value != 0 && value != -1 && value != 1) {        round = true;        break;      }    }    if (round) {      NeuroSynchUtil.ErrorMessage(          "The image orientation vectors do not lie along the orthogonal axes. This"              + " may result in skewing of the images.",          NeuroSynchUtil.kNoDlog);      for (int i = FloatPoint.X; i <= FloatPoint.Z; i++) {        fColumnVector.Set(Math.round(fColumnVector.Get(i)), i);        fRowVector.Set(Math.round(fRowVector.Get(i)), i);      }    }  }  private void readObject(ObjectInputStream s) throws ClassNotFoundException, IOException {    fComplete = false;    s.defaultReadObject();    s.readInt(); // kVersionNum	//	TASK: encapsulate versioning    fComplete = true;  }  private void writeObject(ObjectOutputStream s) throws IOException {    s.defaultWriteObject();    s.writeInt(kVersionNum); // 	TASK: encapsulate versioning  }}