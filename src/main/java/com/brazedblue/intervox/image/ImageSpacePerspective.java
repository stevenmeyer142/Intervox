package com.brazedblue.intervox.image;import java.awt.image.*;import java.awt.*;import javax.vecmath.*;import com.brazedblue.intervox.util.*;import com.brazedblue.intervox.data.*;import com.brazedblue.intervox.geometry.*;import com.brazedblue.intervox.display.ProgressBroadcaster; import com.brazedblue.intervox.registration.TransformerAccess;public class ImageSpacePerspective  {	ImageSpacesAccessor					fImageSpaceAccessor;	ImageFilterAccessor					fImageFilterAccessor;	SingleSpaceID						fMySpace = SingleSpaceID.GetDefaultVirtualSpaceID();	int 								fDepth = 0;	RGBArrayImageSource 				fSlicesSource;	int									fAxis = OrthoImageSetController.kCoronal;	Dimension							fViewDimension = new Dimension(0, 0);		static private DummyImage3DField	fgDummySpace = new DummyImage3DField();	   	public ImageSpacePerspective() 	{    }		protected Image3DField GetImage3DField()	{		Image3DField result = fgDummySpace;				if (fImageSpaceAccessor != null)		{			result = fImageSpaceAccessor.GetImage3DField(fMySpace);		}				return result;	}		protected void SetCurrentPixels(PixelData pixels, int currentSlice)	{		fDepth = currentSlice;		if (ValidImageSource())		{			fSlicesSource.SetPixelData(pixels);		}		else if (Debug.fgDebugging)		{			Debug.PrintStackTrace("invalidated image source");		}		}		protected RGBArrayImageSource CreateImageSource()	{		return new RGBArrayImageSource(false); 	}		public void SetSpaceID(SingleSpaceID spaceID)	{		boolean newSpace = !spaceID.equals(fMySpace);		fMySpace = spaceID;		if (newSpace)		{			SynchWithDataAccessors();		}	} 		public Dimension GetViewDimension()	{		Dimension result = new Dimension();		Image3DField imageField = GetImage3DField();				switch (fAxis)		{			case OrthoImageSetController.kSagittal :				result.width = imageField.MaxCoord(OrthoImageSetController.kCoronal);				result.height = imageField.MaxCoord(OrthoImageSetController.kAxial);				break;							case OrthoImageSetController.kAxial :				result.width = imageField.MaxCoord(OrthoImageSetController.kSagittal);				result.height = imageField.MaxCoord(OrthoImageSetController.kCoronal);				break;			case OrthoImageSetController.kCoronal :				result.width = imageField.MaxCoord(OrthoImageSetController.kSagittal);				result.height = imageField.MaxCoord(OrthoImageSetController.kAxial);				break;			case OrthoImageSetController.kTrajectory :				{					int maxCoord = 0;					for (int i = OrthoImageSetController.kSagittal; i <= OrthoImageSetController.kCoronal; i++)					{						int coord = imageField.MaxCoord(i);						if (coord > maxCoord)						{							maxCoord = coord;						}					}					result.width = maxCoord;					result.height = maxCoord;				}				break;		}				return result;	}		public String GetDescription()	{		String result = OrthoImageSetController.GetAxisIDString(fAxis);		Image3DField imageField = GetImage3DField();		String seriesName = imageField.GetName();				if (seriesName != null)		{			result += "(" + seriesName + ")";		}				return result;	}		public int GetNumberOfSlices()	{		Image3DField imageField = GetImage3DField();		return imageField.MaxCoord(fAxis);	}		public FloatPoint GetFloatPoint(Point viewPt)	{		return GetFloatPoint(viewPt, null);	}			// reverse of GetSliceForPoint(pt) and GetViewPoint	public FloatPoint GetFloatPoint(Point viewPt, FloatPoint floatPt)	{		if (floatPt == null)		{			floatPt = new FloatPoint();		}				if (fAxis != OrthoImageSetController.kTrajectory)		{			floatPt.Set(fDepth, fAxis);						switch (fAxis)			{				case OrthoImageSetController.kSagittal :					floatPt.Set(fViewDimension.width - viewPt.x, OrthoImageSetController.kCoronal);					floatPt.Set(viewPt.y, OrthoImageSetController.kAxial);					break;									case OrthoImageSetController.kAxial :					floatPt.Set(viewPt.x, OrthoImageSetController.kSagittal);					floatPt.Set(fViewDimension.height - viewPt.y, OrthoImageSetController.kCoronal);					break;					case OrthoImageSetController.kCoronal :					floatPt.Set(viewPt.x, OrthoImageSetController.kSagittal);					floatPt.Set(viewPt.y, OrthoImageSetController.kAxial);					break;			}		}		return floatPt;	}		public void SetData(ImageSpacesAccessor spaceAccessor, ImageFilterAccessor filterAccessor)	{		fImageSpaceAccessor = spaceAccessor;		fImageFilterAccessor = filterAccessor;		fMySpace = fImageSpaceAccessor.ResolveSingleSpaceID(fMySpace);					// change 1/25/01//		GetImageProducer();   // creates new image source//		SynchWithDataAccessors();		SynchWithDataAccessors();//		GetImageProducer();   // creates new image source	}   	public Point GetViewPoint(Location3D location, Point viewPoint)	{		float x = 0, y = 0;		if (viewPoint == null)		{			viewPoint = new Point();		}				switch (fAxis)		{			case OrthoImageSetController.kSagittal:		// looking from left				x = fViewDimension.width - location.GetFloat(Location3D.Z_AXIS);				y = location.GetFloat(Location3D.Y_AXIS);				break;			case OrthoImageSetController.kAxial:		// looking up from below with nose toward top				x = location.GetFloat(Location3D.X_AXIS);				y = fViewDimension.height - location.GetFloat(Location3D.Z_AXIS);				break;			case OrthoImageSetController.kCoronal:				x = location.GetFloat(Location3D.X_AXIS);				y = location.GetFloat(Location3D.Y_AXIS);				break;		}				viewPoint.x = Math.round(x);		viewPoint.y = Math.round(y);				return viewPoint;	}	public void Dispose()	{		fImageSpaceAccessor = null; 		fImageFilterAccessor = null;		fSlicesSource = null;	}		public void SetAxis(int axis)	{		fAxis = axis;	}		public int MaxDepth()	{		if (fAxis == OrthoImageSetController.kTrajectory)		{			return 1;		}		else		{			Image3DField imageField = GetImage3DField();			return imageField.MaxCoord(fAxis);		}			}		public void ImageAdjustmentsChanged()	{		if (ValidImageSource())		{			fSlicesSource.ImageAdjustmentsChanged();		}		else if (Debug.fgDebugging)		{			Debug.PrintStackTrace("invalidated image source");		}	}		protected void SetDefaultImage()	{		if (ValidImageSource())		{			if (fAxis == OrthoImageSetController.kTrajectory)			{				float value = (float)Math.sqrt(.5);				Image3DField imageField = GetImage3DField();				PixelData newPixels = imageField.GetSlicePixelData( new FloatPoint(128, 0, 0), 							new ThreeDVector(0, -value, value), new ThreeDVector(0, value, value), 								new Dimension(256, 256));								fSlicesSource.SetPixelData(newPixels);			}					}		else if (Debug.fgDebugging)		{			Debug.PrintStackTrace("invalidated image source");		}	}		public boolean SetToDepth(int depth)	{		boolean result = false;  // not setting pixels		if (ValidImageSource())		{			if (fAxis != OrthoImageSetController.kTrajectory)			{				if (depth >= 0 && depth < MaxDepth() && fDepth != depth)				{					Image3DField imageField = GetImage3DField();					PixelData pixels = imageField.PixelsAtCoord(depth, fAxis);					SetCurrentPixels(pixels, depth);					result = true;				}				else if (MaxDepth() > 0 && fDepth != depth)				{					NeuroSynchUtil.ErrorMessage("depth out of range, ImageSeriesSource.SetToDepth", NeuroSynchUtil.kNoDlog);				}			}		}		else if (Debug.fgDebugging)		{			Debug.PrintStackTrace("invalidated image source");		}				return result;	}		static int 	gDebugCounter = 2;	static public void DebugIncrement()	{		gDebugCounter++;				if (gDebugCounter > 11)		{			gDebugCounter = 0;		}				for (int i = 0; i < gDebugCounter; i++)		{			Toolkit.getDefaultToolkit().beep();		}	}		protected void SynchWithDataAccessors()	{		if (fSlicesSource != null)		{			fSlicesSource.Reset();		}				if (fImageFilterAccessor != null)		{			ImageAdjustments adjustments = fImageFilterAccessor.GetImageAdjustments(fMySpace);			SetImageAdjustments(adjustments);		}				if (fImageSpaceAccessor != null)		{			fViewDimension = GetViewDimension();			fDepth = -1;			SetDefaultImage();		}	}		private int GetUnitsToEdge(Location3D location, Location3D vector)	{		Image3DField field = GetImage3DField();				int result = fViewDimension.height - 1;				for (int axis = Location3D.X_AXIS; axis <= Location3D.Z_AXIS; axis++)		{			float axisVector = vector.GetFloat(axis);			if (axisVector < 0)			{				float axisDistance = -location.GetFloat(axis);								if (axisDistance < 0)				{					int units = (int)(axisDistance / axisVector);										if (units < result)					{						result = units;					}				}								}			else if (axisVector > 0)			{				float axisDistance = field.MaxCoord(axis) - location.GetFloat(axis);								if (axisDistance > 0)				{					int units = (int)(axisDistance / axisVector);										if (units < result)					{						result = units;					}				}								}		}				return result;	}		public void SetTrajectorySlice(TransformerAccess transformer, SingleSpaceID fromSpace, FloatPoint sensorPoint, 				ThreeDVector xIncVector, ThreeDVector yIncVector)	{		if (ValidImageSource())		{			transformer.TransformPoint(sensorPoint, fromSpace, fMySpace);					transformer.TransformVector(xIncVector, fromSpace, fMySpace);			transformer.TransformVector(yIncVector, fromSpace, fMySpace);						xIncVector.normalize();			yIncVector.normalize();						Dimension viewDimension = GetViewDimension();						int unitsToEdge = GetUnitsToEdge(sensorPoint, yIncVector);						FloatPoint startPoint = new FloatPoint();			startPoint.scaleAdd(unitsToEdge - viewDimension.height, yIncVector, sensorPoint);						Image3DField imageField = GetImage3DField();			PixelData newPixels = imageField.GetSlicePixelData(startPoint, xIncVector, yIncVector, 							viewDimension);							// make x crossbar			Histogram histogram = imageField.GetHistogram();			int whiteValue = histogram.GetMaxValue();							int yFocus = viewDimension.height - unitsToEdge - 1;						if (yFocus >= 0 && yFocus < viewDimension.height)			{			for (int x = 0; x < viewDimension.width; x++)			{				if (yFocus > 0)				{					newPixels.SetPixelValue(x, yFocus - 1, 0);				}				if (yFocus >= 0)				{					newPixels.SetPixelValue(x, yFocus, whiteValue);				}//				newPixels.SetPixelValue(x, yFocus + 1, 0);			}		}						int xFocus = viewDimension.width / 2 - 1;			for (int y = 0; y < viewDimension.height; y++)			{				if (y != yFocus)				{					newPixels.SetPixelValue(xFocus - 1, y, 0);				}				newPixels.SetPixelValue(xFocus, y, whiteValue);//				newPixels.SetPixelValue(xFocus + 1, y, 0);			}						fSlicesSource.SetPixelData(newPixels);		}		else if (Debug.fgDebugging)		{			Debug.PrintStackTrace("invalidated image source");		}	}/*			public Image3DField GetSeries()	{		return fImageSeries;	}	 */	private boolean ValidImageSource()	{		return fSlicesSource != null;	}		public ImageProducer GetImageProducer()	{		if (!ValidImageSource())		{			fSlicesSource = CreateImageSource(); //			SetToDepth(MaxDepth() / 2);		}		return fSlicesSource;	}			public int CurrentDepth()	{		return fDepth;	}		private void SetImageAdjustments(ImageAdjustments adjustments)	{		if (!ValidImageSource())		{			GetImageProducer();	//	creates source		}		fSlicesSource.SetImageAdjustments(adjustments);	}				//	so that fImageSeries is never null	private static class DummyImage3DField implements Image3DField	{		private  DummyImage3DField()		{				}				public PixelData PixelsAtCoord(int coord, int axis)		{			return null;		}			public int MaxCoord(int axis)		{			return 0;		}			public Histogram GetHistogram()		{			return null;		}			public String GetName()		{			return "";		}		  	public void RotateToCoronal(int fromAxis, ProgressBroadcaster progress)		{				}			public void Flip(int whichAxis, ProgressBroadcaster progress)		{				}			public PixelData GetSlicePixelData(FloatPoint middlePoint, ThreeDVector xIncVector, 											ThreeDVector yIncVector, Dimension size)		{			return null;									}	};	}  