package com.brazedblue.intervox.image;import com.brazedblue.intervox.util.NeuroSynchUtil;abstract public class PixelData implements java.io.Serializable, java.lang.Cloneable{	protected int	fWidth;	protected int 	fHeight;	protected int 	fPixelSize;		static final long serialVersionUID =  5491748561445634724L;	protected PixelData(int width, int height, int pixelSize)	{		fWidth = width;		fHeight = height;		fPixelSize = pixelSize;	}		static public PixelData NewDataInstance(int width, int height, short[] pixels, int resolution)	{		return new Pixel16BitData(width, height, pixels, resolution);		}		static public PixelData NewDataInstance(int width, int height, byte[] pixels, int resolution)	{		return new Pixel8BitData(width, height, pixels, resolution);		}		static public PixelData NewDataInstance(int width, int height, byte[] pixels)	{                if (pixels == null)                {                    NeuroSynchUtil.ErrorMessage("null pixels in PixelData.NewDataInstance");                }		return NewDataInstance(width, height, pixels, 1);		}		public int GetPixelValue(float x, float y)	{		int intX = (int)x;		int intY = (int)y;				float remX = x - (float)intX;		float remY = y - (float)intY;				float oneMinRemX = 1 - remX;		float oneMinRemY = 1 - remY;		float result = 0;				if (remX < .1 && remY < .1)		{			result = GetPixelValue(intX, intY);		}		else if (remY < .1)		{			result = oneMinRemX * GetPixelValue(intX, intY) + remX * GetPixelValue(intX + 1, intY);		}		else if (remX < .1)		{			result = oneMinRemY * GetPixelValue(intX, intY) + remY * GetPixelValue(intX, intY + 1);		}		else		{			result = 	remX * 						(remY * GetPixelValue(intX + 1 , intY + 1) + 						oneMinRemY * GetPixelValue(intX + 1 , intY)) + 						oneMinRemX * 						(remY * GetPixelValue(intX , intY + 1) + 						oneMinRemY * GetPixelValue(intX , intY));		}				return (int)result;		}		public abstract int GetPixelValue(int x, int y);	public abstract void SetPixelValue(int x, int y, int value);	protected abstract PixelData NewDataObject(int width, int height);		protected abstract Object NewPixelArray(int size);		public abstract void AdjustToUnsigned(int substractedAmount);	protected abstract Object GetPixels();		public int GetMaxValue()	{		return (2 << fPixelSize) - 1;	}		abstract protected void SetPixelData(Object pixels);		abstract protected Object GetPixelsCopy();	public int GetWidth()	{		return fWidth;	}		public int GetHeight()	{		return fHeight;	}		boolean IsIntArray()	{		return fPixelSize == 32;	}		boolean IsShortArray()	{		return fPixelSize == 16;	}		boolean IsByteArray()	{		return fPixelSize == 8;	}		void FlipRowsAndColumns()	{		PixelData newData = NewDataObject(fHeight, fWidth);					for (int y = 0; y < fHeight; y++)		{			for (int x = 0; x < fWidth; x++)			{				newData.SetPixelValue(y, x, GetPixelValue(x, y));			}		}					SetPixelData(newData.GetPixels());				int oldWidth = fWidth;		fWidth = fHeight;		fHeight = oldWidth;	}			void FlipOnYAxis()	{		Object newPixels = NewPixelArray(fWidth * fHeight);		Object oldPixels = GetPixels();				for (int i = 0; i < fHeight; i++)		{			int fromIndex = i * fWidth;						int toIndex = (fHeight - i - 1) * fWidth;			System.arraycopy(oldPixels, fromIndex, newPixels, toIndex, fWidth);		}					SetPixelData(newPixels);	}		void FlipOnXAxis()	{		PixelData newData = NewDataObject(fWidth, fHeight);					for (int i = 0; i < fHeight; i++)		{			for (int j = 0; j < fWidth; j++)			{				newData.SetPixelValue(fWidth - j - 1, i, GetPixelValue(j, i));			}		}					SetPixelData(newData.GetPixels());	}		public Object clone () {	    try { 			PixelData pData = (PixelData)super.clone();						Object pixels = GetPixelsCopy();			pData.SetPixelData(pixels);						return pData;					} catch (CloneNotSupportedException e) { 			// this shouldn't happen, since we are Cloneable			throw new InternalError();		}	}	synchronized void SetNewDimensions(int newWidth, int newHeight)	{		PixelData newData = NewDataObject(newWidth, newHeight);				float widthFract = (float)fWidth / (float)newWidth;		float heightFract = (float)fHeight / (float)newHeight;				for (int y = 0; y < newHeight; y++)		{			for (int x = 0; x < newWidth; x++)			{				newData.SetPixelValue(x, y, GetPixelValue(widthFract * x, heightFract * y));			}		}						fHeight = newHeight;		fWidth = newWidth;		SetPixelData(newData.GetPixels());	}}