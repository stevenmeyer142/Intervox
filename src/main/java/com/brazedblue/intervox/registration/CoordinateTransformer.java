package com.brazedblue.intervox.registration;import java.io.*;import com.brazedblue.intervox.image.*;import com.brazedblue.intervox.data.*;import com.brazedblue.intervox.device.*;import com.brazedblue.intervox.geometry.*;import com.brazedblue.intervox.util.NeuroSynchUtil;import com.brazedblue.intervox.util.Debug;abstract class CoordinateTransformerBase extends DataModel  implements CoordinateTransformerModel, TransformationTypeModel, java.io.Serializable{	private int 					fSelectedPointsDerivation = kUndefinedDerivation;	private String[][]				fLabelList = new String[kDerivationsCount][];	private boolean					fEnabled = true;	static private final String[] 	kLabelNotSet = { "Label not set"};	static private final int		kDerivationsCount = 3;	static private final int		kCustomIndex = 0;	static private final int		k3PointsIndex = 1;	static private final int 		k4PointsIndex = 2;		static final long			serialVersionUID = -6356483274479950707L;	public int GetSelectedPointsDerivation()		{		return fSelectedPointsDerivation;	}		private int GetStringIndex(int pointsDerivation)	{		int result = -1;		switch (pointsDerivation)		{			case kCustomPointsDerived:				result = kCustomIndex;				break;			case k3PointsDerived:				result = k3PointsIndex;				break;			case k4PointsDerived:				result = k4PointsIndex;				break;		}				return result;		}		private void readObject(ObjectInputStream s)      	throws ClassNotFoundException, IOException     {      	s.defaultReadObject();		   }		public String[] GetLabelList(int pointsDerivation)	{		String[] result = null;				int index = GetStringIndex(pointsDerivation);		if (index >= 0)		{			result = fLabelList[index];		}				if (Debug.fgDebugging && false)		{			System.out.println("GetLabelList result -" + result + "\r" + toString());		}				return result;	}		public boolean GetEnabled()	{		return fEnabled;	}		public void SetEnabled(boolean enabled)	{		fEnabled = enabled;	}			public void SetSelectedPointsDerivation(int pointsDerivation)  	{		fSelectedPointsDerivation = pointsDerivation;	}		public void SetLabelList(int pointsDerivation, String[] labelList)	{		int index = GetStringIndex(pointsDerivation);		if (index >= 0)		{			fLabelList[index] = labelList;		}		if (Debug.fgDebugging && false)		{			System.out.println("SetLabelList result -" + labelList + "\r" + toString());		}	}		public String toString() 	{		String result = super.toString();		result += " selected derivation: " + fSelectedPointsDerivation + "\r";						for (short i = 0; i < fLabelList.length; i++)		{			String[] labels = fLabelList[i];			result += labels;			if (labels != null)			{				for (short j = 0; j < labels.length; j++)				{					result += labels[j] + " - ";				}			}						result += "\r";		}				result += "\r";	    return result;	}}class CoordinateTransformer extends CoordinateTransformerBase implements java.io.Serializable {  	SingleSpaceID					fFromSpace = SingleSpaceID.GetRealSpaceID();	SingleSpaceID					fToSpace = SingleSpaceID.GetDefaultVirtualSpaceID();	boolean 						fUsingReference;		private TransformationMatrix	fTransformMatrix = null;//	  	static public final String	kNewTransformString = "New Transform";	static final long			serialVersionUID = -7507884053587890835L;  	CoordinateTransformer(TransformationMatrix matrix, SingleSpaceID fromSpace, SingleSpaceID toSpace) 	{		fTransformMatrix = matrix;		fFromSpace = fromSpace;		fToSpace = toSpace;    }			public boolean CanUseReferenceFrame()	{		return fFromSpace.equals(SingleSpaceID.GetRealSpaceID()) && fTransformMatrix.CanUseReferenceFrame();	}		private TransformationMatrix GetTransformationMatrix()	{		return fTransformMatrix;	}		public boolean CanTransform(SingleSpaceID fromSpace, SingleSpaceID toSpace)	{		boolean result = false;				if (GetEnabled() && fTransformMatrix != null)		{			if ( fFromSpace.equals(fromSpace))			{				result = fToSpace.equals(toSpace);			}			else if ( fFromSpace.equals(toSpace))			{				result = fToSpace.equals(fromSpace);			}		}		return result;	}	public SingleSpaceID GetSpace1()	{		return GetFromSpace();	}	public SingleSpaceID GetSpace2()	{		return GetToSpace();	}	private SingleSpaceID GetFromSpace()	{		return fFromSpace;	}		private SingleSpaceID GetToSpace()	{		return fToSpace;	}		private boolean IsUsingReference()	{		return fUsingReference && CanUseReferenceFrame();	}		public void ProcessLocalizerPoint(LocalizerPointOutput output)	{		int station = output.GetStation();				if (IsReferenceStation(station))		{			UpdateTransformerWithReference(output);		}	} 		public FloatPoint TransformPoint(FloatPoint fromPoint, SingleSpaceID fromSpace, SingleSpaceID toSpace)	{		FloatPoint result = null;		if (CanTransform(fromSpace, toSpace))		{			if (Debug.fgDebugging && true)			{				System.out.println("Transforming point " + fromPoint.toString());				fTransformMatrix.DebugDump();			}			if (fromSpace.equals(fFromSpace))			{				fTransformMatrix.TranslatePoint(fromPoint);			}			else			{				fTransformMatrix.InverseTransformPoint(fromPoint);			}						result = fromPoint;		}				return result;	}		public ThreeDVector TransformVector(ThreeDVector vector, SingleSpaceID fromSpace, SingleSpaceID toSpace)	{		ThreeDVector result = null;		if (CanTransform(fromSpace, toSpace))		{			if (fromSpace.equals(fFromSpace))			{				fTransformMatrix.TransformVector(vector);			}			else			{				fTransformMatrix.InverseTransformVector(vector);			}						result = vector;		}				return result;	}		synchronized private void UpdateTransformerWithReference(LocalizerPointOutput output)	{		if (IsUsingReference())		{			Object rotation = output.GetDataOfType(DeviceOutput.ROTATION_MATRIX);			Object point = output.GetDataOfType(DeviceOutput.ORIG_COORDINATE);			TransformationMatrix transform = GetTransformationMatrix();			if (rotation != null && point != null && transform != null)			{				transform.SetCurrentReference((Matrix3)rotation, (FloatPoint)point);			}					}		}		private boolean IsReferenceStation(int station)	{		return station == DeviceOutput.STATION2;	}/*		protected void TransformOutput(LocalizerPointOutput output)	{		Object realPoint = output.GetDataOfType(DeviceOutput.POINT_COORDINATE);				if ((realPoint != null) && (fTransformMatrix != null) && fTransformMatrix.CanTransform())		{			FloatPoint transformedPt = new FloatPoint((FloatPoint)realPoint);						if (transformedPt != null)			{				fTransformMatrix.TranslatePoint(transformedPt);								output.SetTransformedCoord(transformedPt);			}		}	} */		void SetTransformationMatrix(TransformationMatrix transformMatrix)	{		fTransformMatrix = transformMatrix;				if (fTransformMatrix != null && fUsingReference)		{			if (fTransformMatrix.CanUseReferenceFrame())			{				try				{					fTransformMatrix.SetUsingReferenceFrame(fUsingReference);				}				catch (ComputationException e)				{					NeuroSynchUtil.ErrorMessage("CoordinateTransformer.SetTransformationMatrix(), matrix can't use reference.", 										NeuroSynchUtil.kNoDlog);				}			}			else			{				NeuroSynchUtil.ErrorMessage("CoordinateTransformer.SetTransformationMatrix(), matrix can't use reference.", 										NeuroSynchUtil.kNoDlog);			}					}		if (fTransformMatrix != null && Debug.fgDebugging)		{			fTransformMatrix.DebugDump();		}	}		public void SetUsingReference(boolean set)	{		if (fUsingReference != set && CanUseReferenceFrame())		{						try			{				if (fTransformMatrix != null)				{					fTransformMatrix.SetUsingReferenceFrame(set);				}				fUsingReference = set;			}			catch (ComputationException e)			{				NeuroSynchUtil.ErrorMessage("Couldn't set using reference, " + set + ". " + e.getMessage(), NeuroSynchUtil.kShowDlog);							}		}	}}	class SecondaryTransformer extends CoordinateTransformerBase implements java.io.Serializable{	private CoordinateTransformerModel 	fTransformer1;	private CoordinateTransformerModel 	fTransformer2;	private SingleSpaceID 				fFromSpace; 	private SingleSpaceID 				fMiddleSpace;	private SingleSpaceID 				fToSpace;	static final long					serialVersionUID = -5889937951757276997L;		SecondaryTransformer(CoordinateTransformerModel transformer1, CoordinateTransformerModel transformer2,				SingleSpaceID fromSpace, SingleSpaceID middleSpace, SingleSpaceID toSpace)	{		fTransformer1 = transformer1;		fTransformer2 = transformer2;		fFromSpace = fromSpace;		fMiddleSpace = middleSpace;		fToSpace = toSpace;	}		public boolean UsesTransformer(CoordinateTransformerModel transformer)	{		return transformer == fTransformer1 || fTransformer2 == transformer;	} 		public boolean CanTransform(SingleSpaceID fromSpace, SingleSpaceID toSpace)	{		CoordinateTransformerModel transform1 = GetFirstTransformer(fromSpace);		CoordinateTransformerModel transform2 = GetSecondTransformer(fromSpace);				return transform1.CanTransform(fromSpace, fMiddleSpace) && transform2.CanTransform(fMiddleSpace, toSpace);	}	public SingleSpaceID GetSpace1()	{		return fFromSpace;	}		public SingleSpaceID GetSpace2()	{		return fToSpace;	}		public void ProcessLocalizerPoint(LocalizerPointOutput output)	{		fTransformer1.ProcessLocalizerPoint(output);		fTransformer2.ProcessLocalizerPoint(output);	}		public boolean CanUseReferenceFrame()	{		return fTransformer1.CanUseReferenceFrame() || fTransformer2.CanUseReferenceFrame();	}		public void SetUsingReference(boolean set)	{		if (fTransformer1.CanUseReferenceFrame())		{			fTransformer1.SetUsingReference(set);		}		if (fTransformer2.CanUseReferenceFrame())		{			fTransformer2.SetUsingReference(set);		}	}		public ThreeDVector TransformVector(ThreeDVector vector, SingleSpaceID fromSpace, SingleSpaceID toSpace)	{		CoordinateTransformerModel transform1 = GetFirstTransformer(fromSpace);		CoordinateTransformerModel transform2 = GetSecondTransformer(fromSpace);				ThreeDVector result = transform1.TransformVector(vector, fromSpace, fMiddleSpace);		if (result != null)		{			result = transform2.TransformVector(vector, fMiddleSpace, toSpace);		}				return result;	}		public FloatPoint TransformPoint(FloatPoint fromPoint, SingleSpaceID fromSpace, SingleSpaceID toSpace)	{		CoordinateTransformerModel transform1 = GetFirstTransformer(fromSpace);		CoordinateTransformerModel transform2 = GetSecondTransformer(fromSpace);				FloatPoint result = transform1.TransformPoint(fromPoint, fromSpace, fMiddleSpace);		if (result != null)		{			result = transform2.TransformPoint(fromPoint, fMiddleSpace, toSpace);		}				return result;	}		private CoordinateTransformerModel GetFirstTransformer(SingleSpaceID fromSpace)	{		if (fFromSpace.equals(fromSpace))		{			return fTransformer1;		}		else		{			return fTransformer2;		}	}		private CoordinateTransformerModel GetSecondTransformer(SingleSpaceID fromSpace)	{		if (fFromSpace.equals(fromSpace))		{			return fTransformer2;		}		else		{			return fTransformer1;		}	}}