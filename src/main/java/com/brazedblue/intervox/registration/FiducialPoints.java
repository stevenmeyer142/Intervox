package com.brazedblue.intervox.registration;import java.util.*;import java.io.*;import com.brazedblue.intervox.geometry.*;import com.brazedblue.intervox.util.*;import com.brazedblue.intervox.data.*;public class FiducialPoints extends DataModel implements Serializable  {  	private Vector				fPoints = new Vector();				//	this allows a delete/then create operation to retain the same index name	private Vector				fPointsNameList = new Vector();		static final int			kVersionNum = 1;	static final long			serialVersionUID = -8220875893292600283L;		static public final String 	k1PointDeletedMsg = "1 Fid Delete";	static public final String 	kAllPointsDeletedMsg = "All Fids Delete";    public FiducialPoints() 	{    }	private void readObject(ObjectInputStream s)      	throws ClassNotFoundException, IOException     {      	s.defaultReadObject();		s.readInt();	// kVersionNum    }	private void writeObject(ObjectOutputStream s)      throws IOException     {      	s.defaultWriteObject();		s.writeInt(kVersionNum);    }		private void RemoveFromNameList(FiducialPoint point)	{		int index = fPointsNameList.indexOf(point);		fPointsNameList.setElementAt(null, index);		}		private void SetDefaultPointName(Image3DFiducialPoint point)	{		synchronized (fPointsNameList)		{			int size = fPointsNameList.size();			int nameIndex = size;						for (int i = 0; i < size; i++)			{				if (fPointsNameList.elementAt(i) == null)				{					nameIndex = i;					break;				}			}						if (nameIndex == size)			{				fPointsNameList.insertElementAt(point, nameIndex);			}			else			{				fPointsNameList.setElementAt(point, nameIndex);							}			String name = Integer.toString(nameIndex + 1);						point.SetName(name);		}	}		public synchronized FiducialPoint[] GetFiducials()	{		FiducialPoint[] result = new FiducialPoint[fPoints.size()];				fPoints.copyInto(result);		return result;	}		public void DeleteAll()	{		fPoints.removeAllElements();		fPointsNameList.removeAllElements();				PostChanged(new DataChangedEvent(this, DataChangedEvent.CHANGED, 0, kAllPointsDeletedMsg));	}		public boolean HasPoint(Location3D location)	{		return GetFiducialPoint(location) != null;	}	public  void AddPoint(Location3D location)	{		Image3DFiducialPoint point = new Image3DFiducialPoint(location, "");		SetDefaultPointName(point);		AddPoint(point);	}		protected void AddPoint(FiducialPoint point)	{		int index = fPointsNameList.indexOf(point);						if (index >= 0)		{			fPoints.insertElementAt(point, index);		}		else		{			fPoints.addElement(point);		}				PostChanged(new DataChangedEvent(this, DataChangedEvent.CHANGED, 0, "Point added"));	}		public FiducialPoint GetFiducialPoint(Location3D location)	{		Enumeration iter = fPoints.elements();		FiducialPoint result = null;		while (iter.hasMoreElements())		{			FiducialPoint fid = (FiducialPoint)iter.nextElement();					if (FloatPoint.CompareLocation3D(fid.GetLocation(), location) == 0)			{				result = fid;				break;			}		}				return result;	}		public void DeletePoint(Location3D point)	{				int size = fPoints.size();		for (int i = 0; i < size; i++)		{			FiducialPoint fiducial = (FiducialPoint)fPoints.elementAt(i);						if (point.equals(fiducial.GetLocation()))			{				fPoints.removeElement(fiducial);				RemoveFromNameList(fiducial);				break;			}		}				PostChanged(new DataChangedEvent(this, DataChangedEvent.CHANGED, 0, k1PointDeletedMsg));	}/*		public PointPair[] GetPtPairsForVirtualPts(FloatPoint[] virtualPts)	{		PointPair[] result = new PointPair[virtualPts.length];				for (int j = 0; j < virtualPts.length; j++)		{			boolean pointFound = false;						int size = fPoints.size();			for (int i = 0; i < size; i++)			{				PointPair pair = (PointPair)fPoints.elementAt(i);								if (virtualPts[j] == pair.GetVirtualPt())				{					result[j] = pair;					pointFound = true;					break;				}			}			if (!pointFound)			{				NeuroSynchUtil.ErrorMessage("Pair not found in FiducialPoints.GetPtPairsForVirtualPts", NeuroSynchUtil.kNoDlog);				result = null;				break;			}		}				return result;	}		public void AddListener(DataModelListener listener)	{		if (Debug.fgDebugging)		{			Debug.PrintStackTrace("(listener) " + listener);		}				super.AddListener(listener);	}		public void RemoveListener(DataModelListener listener)	{		if (Debug.fgDebugging)		{			Debug.PrintStackTrace("(listener) " + listener);		}				super.RemoveListener(listener);	}		public PointPair[] GetRegisteredPointPairs()	{		int size = fPoints.size();		int count = 0;		for (int i = 0; i < size; i++)		{			PointPair pair = (PointPair)fPoints.elementAt(i);						if (pair.GetRealPt() != null)			{				count++;			}		}				PointPair[] result = new PointPair[count];		count = 0;		for (int i = 0; i < size; i++)		{			PointPair pair = (PointPair)fPoints.elementAt(i);						if (pair.GetRealPt() != null)			{				result[count++] = pair;			}		}				return result;	}		public Vector GetPointPairs()	{		return fPoints;	}	 		public void AddRealPoint(FloatPoint realPoint, FloatPoint virtualPoint, ReferenceState refState)	{		int size = fPoints.size();		for (int i = 0; i < size; i++)		{			PointPair pair = (PointPair)fPoints.elementAt(i);						if (virtualPoint == pair.GetVirtualPt())			{				pair.SetRealPt(realPoint);				pair.SetReferenceState(refState);				break;			}		}	}		public void ClearRealPoints()	{		int size = fPoints.size();		for (int i = 0; i < size; i++)		{			PointPair pair = (PointPair)fPoints.elementAt(i);			pair.SetRealPt(null);		}				PostChanged(new DataChangedEvent(this, DataChangedEvent.CHANGED, 0, "Real points deleted"));	}*/	}