package com.brazedblue.intervox.serial;import java.io.*;import com.brazedblue.intervox.util.*;public class MacSerialDriver implements /*com.apple.NativeObject , */ SerialDriver {		static private final String kDriverNotOpen = "Error: Driver not open.";				static private final short kBufferSize = 10 * 1028;				public static final short baud300 = 380; /*300 baud*/		public static final short baud600 = 189; /*600 baud*/		public static final short baud1200 = 94; /*1200 baud*/		public static final short baud1800 = 62; /*1800 baud*/		public static final short baud2400 = 46; /*2400 baud*/		public static final short baud3600 = 30; /*3600 baud*/		public static final short baud4800 = 22; /*4800 baud*/		public static final short baud7200 = 14; /*7200 baud*/		public static final short baud9600 = 10; /*9600 baud*/		public static final short baud14400 = 6; /*14400 baud*/		public static final short baud19200 = 4; /*19200 baud*/		public static final short baud28800 = 2; /*28800 baud*/		public static final short baud38400 = 1; /*38400 baud*/		public static final short baud57600 = 0; /*57600 baud*//*values for the number of stop bits in the SerConfig parameter*/		public static final short stop10 = 16384; /*1 stop bit*/		public static final short stop15 = -32768; /*1.5 stop bits*/		public static final short stop20 = -16384; /*2 stop bits*//*values for the parity in the SerConfig parameter*/		public static final short noParity = 0; /*no parity*/		public static final short oddParity = 4096; /*odd parity*/		public static final short evenParity = 12288; /*even parity*/				public static final short data5 = 0; /*5 data bits*/		public static final short data6 = 2048; /*6 data bits*/		public static final short data7 = 1024; /*7 data bits*/		public static final short data8 = 3072; /*8 data bits*/    /**     * Macintosh driver reference number      */	short 	fRefNum = 0;	int		fBuffer = 0;    /**     * Driver name "A.in" etc....      */	String 	fName;    /**     * The serial port configuration- whichPort, baudRate, parity, stopBits, dataBits     */	short configBytes = 0;		public MacSerialDriver(String deviceName)	{		fName = deviceName;	}		public boolean IsOpen()	{		return fRefNum != 0;	}	public void SetConfiguration(short baudRate, 							short parity, short stopBits, short dataBits)	{		configBytes = (short)(baudRate + parity + stopBits + dataBits);			}	    /**     * Opens port if not already open.     */	public void Open() throws IOException	{		if (fRefNum == 0)		{			short[] p = new short[1];						short err = OpenDriver(toStr255(fName), p);			if (err == 0)			{				fRefNum = p[0];								if (configBytes != 0 && false)				{					err = SerReset(fRefNum, configBytes);				}			}						fBuffer = NewPtr(kBufferSize);			if (fBuffer != 0)			{				SerSetBuf(fRefNum, fBuffer, kBufferSize);			}			if (err != 0)			{				throw new IOException("OS error # " + err);			}		}	}		public int GetAvailableBytes() throws IOException	{		int result = 0;				if (fRefNum != 0)		{			int[] intPtr = new int[1];						short err = SerGetBuf(fRefNum, intPtr);			result = intPtr[0];						if (err != 0)			{				throw new IOException("Error getting serial buffer count, error #- " + err);			}		}		else		{				NeuroSynchUtil.ErrorMessage(kDriverNotOpen, NeuroSynchUtil.kNoDlog);				throw new IOException(kDriverNotOpen);		}					return result;	}	    /**     * Closes port if not already closed.     */	public void Close() throws IOException	{		if (fRefNum != 0)		{			if (fBuffer != 0)			{				SerSetBuf(fRefNum, fBuffer, (short)0);				DisposePtr(fBuffer);				fBuffer = 0;			}			short err = CloseDriver(fRefNum);			fRefNum = 0;		//	set it to zero even if there was an error			if (err != 0)			{				throw new IOException("OS error # " + err);			}		}	}		public void Write(byte[] byteArray) throws IOException	{		if (fRefNum != 0)		{			int[] intPtr = new int[1];			intPtr[0] = byteArray.length;						short err = FSWrite(fRefNum, intPtr, byteArray);						if (err != 0)			{				throw new IOException("OS error # " + err);			}		}		else		{				NeuroSynchUtil.ErrorMessage(kDriverNotOpen, NeuroSynchUtil.kNoDlog);				throw new IOException(kDriverNotOpen);		}	}	public int Read(byte[] byteArray) throws IOException	{		int result = 0;		if (fRefNum != 0)		{			int[] intPtr = new int[1];			intPtr[0] = byteArray.length;						short err = FSRead(fRefNum, intPtr, byteArray);			result = intPtr[0];			if (err != 0)			{				throw new IOException("OS error # " + err);			}		}		else		{				NeuroSynchUtil.ErrorMessage(kDriverNotOpen,NeuroSynchUtil.kNoDlog);				throw new IOException(kDriverNotOpen);		}			                return result;	}		private static byte[] toStr255(String str) {		int length = str.length();		if (length > 255) length = 255;		byte result[] = new byte[length + 1];		result[0] = (byte)length;		byte[] byteString = str.getBytes();                for (int i = 0; i < length; i++)                {                    result[i + 1] = byteString[i];                }		return result;	}	private native static short SerGetBuf (short refNum, int[] count);	private native static short SerReset(short refNum, short serConfig);	private native static short SerSetBuf(short refNum, int serBPtr, short serBLen);	private native static int NewPtr(int byteCount);    private native static void DisposePtr(int p);	private native static short OpenDriver (byte[] name, short[] drvrRefNum);	private native static short CloseDriver (short refNum);	private native static short FSWrite (short refNum, int[] count, byte[] buffer);	private native static short FSRead (short refNum, int[] count, byte[] buffer);	private static String[] kNativeLibraryNames = { "InterfaceLib" };}