#include "NativeOpenGL.h"#include "JNICommon.h"#include "utility/CMyError.h"bool GetJIntField(jint &intVal, JNIEnv *env, jobject obj, jclass cls, const char* fieldName);bool JavaIntArrayToRect( JNIEnv *env, jintArray jRect, Rect &rect){	jboolean isCopy;        jint* fields = env->GetIntArrayElements(jRect, &isCopy);	CMyError::CheckForJNIException (env); 	CMyError::ThrowErrorIfNULL (fields, "JavaIntArrayToRect");	rect.left = (short)fields[0];	rect.top = (short)fields[1];	rect.right = (short)(fields[0] + fields[2]);	rect.bottom = (short)(fields[1] + fields[3]); 		env->ReleaseIntArrayElements(jRect, fields, 0);	CMyError::CheckForJNIException (env); 		return true;}void FillErrRecord(JNIEnv *env, CMyError &err, jobjectArray errStrings){	SetErrorCodeAndMessage (env, err.GetErrorCode(), err.GetMessage(), errStrings);}void SetErrorCodeAndMessage(JNIEnv *env, long code, char* message, jobjectArray errStrings, bool alert){        if (code != 0)        {            char	codeStr[256];            ::sprintf(codeStr, "%d", (int)code);            jstring errString = env->NewStringUTF(codeStr);            env->SetObjectArrayElement(errStrings, 0, errString);                        if (env->ExceptionOccurred())            {                    return;            }	        }        if (message != 0)        {            jstring errString = env->NewStringUTF(message);            env->SetObjectArrayElement(errStrings, 1, errString);                        if (env->ExceptionOccurred())            {                    return;            }	        }        if (alert)        {            jstring errString = env->NewStringUTF("alert");            env->SetObjectArrayElement(errStrings, 2, errString);                        if (env->ExceptionOccurred())            {                    return;            }	        }//	env->ExceptionClear();/*	if (!env->ExceptionOccurred())	//	can't call JNi during an exception	{		jclass errClass = env->FindClass("neurosynch/view3D/NativeError");				if (env->ExceptionOccurred())		{			return;		}			jint errCode = code;		jstring errString = NULL;				if (message != NULL)		{			errString = env->NewStringUTF(message);		}				if (env->ExceptionOccurred())		{			return;		}				jmethodID methodID = env->GetMethodID(errClass,				"SetError", "(ILjava/lang/String;)V");				if (methodID == 0 || env->ExceptionOccurred())		{			return;		}				env->CallVoidMethod(errRecord, methodID, errCode, errString);		if (env->ExceptionOccurred())		{			return;		}				methodID = env->GetMethodID(errClass,				"SetAlert", "(Z)V");				if (methodID == 0 || env->ExceptionOccurred())		{			return;		}				env->CallVoidMethod(errRecord, methodID, alert);	}        */}void DebugMessage(JNIEnv *env, char* message, jobject errRecord){	if (!env->ExceptionOccurred())	//	can't call JNi during an exception	{		jclass errClass = env->FindClass("neurosynch/view3D/NativeError");				if (env->ExceptionOccurred())		{			return;		}			jstring errString = NULL;				if (message != NULL)		{			errString = env->NewStringUTF(message);		}				if (env->ExceptionOccurred())		{			return;		}				jmethodID methodID = env->GetMethodID(errClass,				"DebugMessage", "(Ljava/lang/String;)V");				if (methodID == 0 || env->ExceptionOccurred())		{			return;		}				env->CallVoidMethod(errRecord, methodID, errString);		if (env->ExceptionOccurred())		{			return;		}	}	}bool GetJIntField(jint &intVal, JNIEnv *env, jobject obj, jclass theClass, const char* fieldName){	jfieldID fieldID = env->GetFieldID(theClass, fieldName, "I");		if (!fieldID)		return false;		intVal = env->GetIntField(obj, fieldID);	return true;}void JavaArrayToGLFloat(JNIEnv *env, jfloatArray array, GLfloat* glfloat, int size){    jfloat buf[size];    jsize arraySize = env->GetArrayLength(array);    CMyError::CheckForJNIException (env);         if (arraySize < size)    {            CMyError::ThrowErrorIfNULL(NULL, "::JavaArrayToGLFloat, bad array");    }    env->GetFloatArrayRegion(array, 0, size, buf);    CMyError::CheckForJNIException (env);          for (int i = 0; i < size; i++)    {   	glfloat[i] = buf[i];    }}void GLFloatToJavaArray(JNIEnv *env, GLfloat* glfloat, jfloatArray array, int size){    jfloat buf[size];    jsize arraySize = env->GetArrayLength(array);    CMyError::CheckForJNIException (env);         if (arraySize < size)    {            CMyError::ThrowErrorIfNULL(NULL, "::GLFloatToJavaArray, bad array");    }       for (int i = 0; i < size; i++)    {        buf[i] = glfloat[i];    }    env->SetFloatArrayRegion(array, 0, size, buf);    CMyError::CheckForJNIException (env); }