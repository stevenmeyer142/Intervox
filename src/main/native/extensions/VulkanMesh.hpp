// VulkanMesh.h// Created by Steve on Fri, Jun 23, 2000 @ 12:16 PM.#ifndef __VulkanMesh__#define __VulkanMesh__#pragma once// TODO make these defines global#define GLM_FORCE_RADIANS#define GLM_FORCE_DEPTH_ZERO_TO_ONE#include <glm/glm.hpp>#include "VulkanBuffer.h"#include "VulkanDevice.h"#include "VulkanPipeline.hpp"class CTriangleList;class CVertexList;struct MeshVertex{    float pos[3];    float normal[3];    MeshVertex() {        pos[0] = 0;        pos[1] = 0;        pos[2] = 0;        normal[0] = 1;        normal[1] = 0;        normal[2] = 0;    }    MeshVertex(const float p[3], const float n[3])    {        pos[0] = p[0];        pos[1] = p[1];        pos[2] = p[2];        normal[0] = n[0];        normal[1] = n[1];        normal[2] = n[2];    }    MeshVertex(const glm::vec3& p, const glm::vec3& n)    {        pos[0] = p.x;        pos[1] = p.y;        pos[2] = p.z;        normal[0] = n.x;        normal[1] = n.y;        normal[2] = n.z;    }        friend std::ostream& operator<<(std::ostream& os, const MeshVertex& dt)    {        os << "pos[" << dt.pos[0] << "," << dt.pos[1] << "," << dt.pos[2] << "],"        << "normal[" << dt.normal[0] << "," << dt.normal[1] << "," << dt.normal[2] << "]";        return os;    }};class VulkanMesh{public:	VulkanMesh(vks::VulkanDevice *vulkanDevice);	    virtual ~VulkanMesh();    	void Draw(VkCommandBuffer cmdbuffer, VkPipelineLayout pipelineLayout);		void AddTriangles(CTriangleList &triangles, CVertexList &vertices, VkQueue queue);        void addVertexData(std::vector<MeshVertex>& vBuffer, std::vector<uint32_t>& iBuffer,                       VkQueue queue);        void updateUniformBuffer(const glm::mat4 &perspective, const glm::mat4 &view, const glm::mat4 &model);        void setupDescriptorSet(VkDescriptorPool pool, VkDescriptorSetLayout descriptorSetLayout);		static void DebugTestDraw();		void DebugDrawNormals();        void setWeightedCenter(const glm::vec3 &weightedCenter) { fWeightedCenter = weightedCenter; }        void setWeight(const float &weight) { fWeight = weight; }    glm::vec3 setWeightedCenter() { return fWeightedCenter; }        float getWeight() { return fWeight; }        mesh_id_t getMeshID() { return fMeshID; }        void setColor(const glm::vec3& color) { fColor = color; }        float getOffset() { return 0; }        float getScale() { return 1; }private:        void prepareUniformBuffer();		void DebugLookAtTriangles();	void freeBuffers();	    struct UBO    {        glm::mat4 projection;        glm::mat4 model;        glm::mat4 normal;        glm::mat4 view;        glm::vec4 color;        glm::vec3 lightPos;    };    vks::VulkanDevice *fVulkanDevice;    glm::vec3 fColor;    vks::Buffer fVertexBuffer;    vks::Buffer fIndexBuffer;    size_t fIndexCount = 0;    UBO fUbo;    vks::Buffer fUniformBuffer;    VkDescriptorSet fDescriptorSet = VK_NULL_HANDLE;    glm::vec3   fWeightedCenter;    float       fWeight = 1.0;    mesh_id_t     fMeshID = 0;        static int32_t    gNextMeshID;};#endif