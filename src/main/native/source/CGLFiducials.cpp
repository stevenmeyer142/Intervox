// CGLFiducials.cp// Created by Steve on Thu, Aug 17, 2000 @ 3:29 PM.#include "NativeOpenGL.h"#ifndef __CGLFiducials__#include "CGLFiducials.h"#endif#include "utility/C3DFloatPoint.h"//#include <OpenGL/glu.h>#include <GLUT/glut.h>#include "utility/CMyError.h"// #include "CGLTexFont.h"#include <stdlib.h>class CFiducial{	C3DFloatPoint	fLocation;	char*			fLabel;public :		CFiducial(float* location, const char* label);		virtual ~CFiducial();		C3DFloatPoint*	GetLocation() { return &fLocation; }		const char*		GetLabel() { return fLabel; }private :	void ReleaseText();};CFiducial::CFiducial(float* location, const char* label) : fLocation(location), fLabel(NULL){	if (label)	{		long strlength = ::strlen(label) + 1;				fLabel = (char*)::malloc(strlength);				if (fLabel)		{			::strncpy(fLabel, label, strlength);		}	}}#pragma segment MainCFiducial::~CFiducial(){	ReleaseText();}#pragma segment Mainvoid CFiducial::ReleaseText(){	if (fLabel)	{		::free(fLabel);		fLabel = NULL;	}}CGLFiducials::CGLFiducials() : fTransparency(0.8) {}CGLFiducials::~CGLFiducials(){	long count = fPointList.GetSize();	for (long i = 1; i <= count; i++)	{		CFiducial *pt = (CFiducial*)fPointList.GetElementAt (i);		delete pt;	}		fPointList.RemoveAllItems ();}#pragma segment void CGLFiducials::Render(bool lowRes)//Override{//	CGLTexFont *texFont = CGLTexFont::GetDefaultTexFont ();	long count = fPointList.GetSize();	float color[4] = { 1, .5, 0, 1 };	color[3] = fTransparency;		const short kFiducialSize = 6; 	::glPushAttrib(GL_CURRENT_BIT | GL_LIGHTING_BIT); 	GLUquadricObj *qobj = ::gluNewQuadric();  	::gluQuadricDrawStyle(qobj, GLU_FILL);  	long listID = ::glGenLists(1);  	::glNewList(listID, GL_COMPILE);  /* create sphere display list */  	::gluSphere(qobj, kFiducialSize, kFiducialSize,  kFiducialSize);  	::glEndList();	for (long i = 1; i <= count; i++)	{		::glPushMatrix();		CFiducial *fiducial = (CFiducial*)fPointList.GetElementAt (i);		::glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, color);		C3DFloatPoint *pt = fiducial->GetLocation ();		::glTranslatef(pt->fX, pt->fY, pt->fZ);		::glCallList(listID);				const char* label = fiducial->GetLabel();				if (/*texFont && */label)		{			::glPushAttrib(GL_ENABLE_BIT + GL_CURRENT_BIT + GL_LINE_BIT);			::glPushMatrix();					glDisable(GL_LIGHTING);			glDisable(GL_TEXTURE_2D);			glColor4fv(color);			glLineWidth(6);			RotateTowardViewer();			::glTranslatef(-kFiducialSize, kFiducialSize, 0);			::glScalef(.3, .3, .3);			if (1)			{				const char *p;				for (p = label; *p; p++)				{					::glutStrokeCharacter(GLUT_STROKE_ROMAN, *p);//					::glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, 'D');				}			}			else			{//				texFont->txfRenderString(label, strlen(label));			}						::glPopMatrix();			::glPopAttrib();					}		::glPopMatrix();	}	::glDeleteLists(listID, 1);	::gluDeleteQuadric(qobj);	::glPopAttrib();	}#pragma segment void CGLFiducials::AddFiducial(float *location, const char* label){	CFiducial *fiducial = new CFiducial(location, label);		fPointList.InsertLast (fiducial);}#pragma segment #ifndef kNOJNICGLFiducials* CGLFiducials::CreateFiducialsFromList(JNIEnv *env, jobjectArray float2dLocations, jobjectArray string1DLabels){	CGLFiducials *result = NULL;	try	{	   	jsize count = env->GetArrayLength(float2dLocations);		CMyError::CheckForJNIException(env, "Accessing Fiducials list.");											// get "String" info			 				result = new CGLFiducials ();		for (long i = 0; i < count; i++)		{	   		jfloatArray floatArray = (jfloatArray)env->GetObjectArrayElement(float2dLocations, i);			CMyError::CheckForJNIException(env);								float location[3];                        jboolean isCopy;                        jfloat* floats = env->GetFloatArrayElements(floatArray, &isCopy);                        CMyError::CheckForJNIException (env);                         CMyError::ThrowErrorIfNULL (floats, "NSQD3DDataObject::SetPointWithArray");                                        for (int j = 0; j < 3; j++)                        {                            location[j] = floats[j];                        }                                        env->ReleaseFloatArrayElements(floatArray, floats, 0);                        CMyError::CheckForJNIException (env); 						const char *label = NULL;			jobject labelObj = NULL;			if (string1DLabels != NULL)			{		   		labelObj = env->GetObjectArrayElement(string1DLabels, i);				CMyError::CheckForJNIException(env, "Accessing fiducial label array");								jboolean isCopy;				label =  env->GetStringUTFChars((jstring)labelObj, &isCopy);				CMyError::CheckForJNIException(env, "accessing fiducial label characters");			}			result->AddFiducial(location, label);						if (string1DLabels != NULL)			{				env->ReleaseStringUTFChars((jstring)labelObj, label);				CMyError::CheckForJNIException(env, "releasing fiducial label characters");			}		}	}	catch (CMyError err)	{		if (result != NULL)		{			delete result;		}				throw;	}		return result;}#endif#pragma segment Mainvoid CGLFiducials::Offset(const C3DFloatPoint &offset){	long count = fPointList.GetSize();	for (long i = 1; i <= count; i++)	{		C3DFloatPoint *pt = (C3DFloatPoint*)fPointList.GetElementAt (i);		*pt += offset;	}}#pragma segment bool CGLFiducials::IsOpaque()//Override{	return fTransparency == 1.0;}#pragma segment Mainvoid CGLFiducials::RotateTowardViewer(){	// basically remove everything but translation from the model and projection matrices	float	matrix[16];		glGetFloatv(GL_MODELVIEW_MATRIX, matrix);		::glLoadIdentity();	::glTranslatef(matrix[12], matrix[13], matrix[14]);	::glRotatef(180, 1, 0, 0);}