// CGLMeshRenderer.cp// Created by Steve on Mon, Dec 11, 2000 @ 1:55 PM.#include "NativeOpenGL.h"#ifndef __CGLMeshRenderer__#include "CGLMeshRenderer.h"#endif#ifndef __CGLMeshHolder__#include "CGLMeshHolder.h"#endif#include "CGLMesh.h"#ifndef kNOJNI#include "utility/CJavaArrSlicesSet.h"#endif#include "utility/CCubeMarcher.h"#include "utility/C3DPoint.h"const bool kUseList = false;#define kDebugSurface 0#define kShowVectors 0CGLMeshRenderer::CGLMeshRenderer()  : 		 fLowResMesh(NULL), fHighResMesh(NULL), fHighResValue(-1),		fHighResListID(0), fLowResListID(0), 		fCenter(0, 0, 0), fWeight(0){}CGLMeshRenderer::~CGLMeshRenderer(){	Deallocate();}void CGLMeshRenderer::Deallocate(){	if (::glIsList(fHighResListID))	{		::glDeleteLists(fHighResListID, 1);	}		if (::glIsList(fLowResListID))	{		::glDeleteLists(fLowResListID, 1);	}		if (fHighResMesh)	{		delete fHighResMesh;		fHighResMesh = NULL;	}	if (fLowResMesh)	{		delete fLowResMesh;		fLowResMesh = NULL;	}}#pragma segment void CGLMeshRenderer::Render(bool lowRes)//Override{	if (kScaleTriangles)	{		::glPushMatrix();		::glScalef(1 / kScaleFactor, 1 / kScaleFactor, 1 / kScaleFactor);	}	if (lowRes && fLowResMesh)	{		if (kUseList)		{			if (!::glIsList(fLowResListID))			{				fLowResListID = ::glGenLists(1);				::glNewList(fLowResListID, GL_COMPILE);				fLowResMesh->Render();				::glEndList();			}			::glCallList(fLowResListID);		}		else		{			fLowResMesh->Render();		}	}	else if (fHighResMesh)	{		if (kUseList)		{			if (!::glIsList(fHighResListID))			{				fHighResListID = ::glGenLists(1);				::glNewList(fHighResListID, GL_COMPILE);				fHighResMesh->Render();				::glEndList();			}			::glCallList(fHighResListID);		}		else		{			fHighResMesh->Render();		}	}			if (kShowVectors)	{		DebugShowNormals(lowRes);	}	if (kScaleTriangles)	{		::glPopMatrix();	}	}#pragma segment bool CGLMeshRenderer::GetCenter(C3DPoint &center, long &weight)//Override{	center = fCenter; 	weight = fWeight;  	return true; }void CGLMeshRenderer::CreateGeometries(JNIEnv *env, jint width, jint height, jobjectArray objArrays,         jint regionValue, jint resolution){		fWeight = 0; 		fCenter = C3DPoint(0, 0, 0);                fHighResValue = resolution;				CJavaArrSlicesSet slicesSet(env, objArrays, width, height);				C3DPoint startPoint(0, 0, 0);				CCubeMarcher marcher(&slicesSet, 2, regionValue, startPoint);				GeometryInfo info;				fLowResMesh = marcher.GetGLMesh(6, info);                                if (fHighResValue <= 0)                {                    fHighResValue = 2;                    if (info.numOfVertices > 12000)	                    {                            fHighResValue = 4;                    }                    else if (info.numOfVertices > 7000)		                    {                            fHighResValue = 3;                    }                    }				fHighResMesh = marcher.GetGLMesh(fHighResValue, info); 				if (true)		{			ComputeWeightedCenter (slicesSet, regionValue);		}}#pragma segment Mainvoid CGLMeshRenderer::DebugShowNormals(bool lowRes){	if (kShowVectors)	{		if (lowRes && fLowResMesh)		{			fLowResMesh->DebugDrawNormals ();		}		else if (fHighResMesh)		{			fHighResMesh->DebugDrawNormals ();		}	}}#pragma segment Mainvoid CGLMeshRenderer::ComputeWeightedCenter(CSlicesSet &slicesSet, short region){	C3DPoint center = C3DPoint(0, 0, 0);	long weight = 0;		long depth = slicesSet.GetDepth ();	long width = slicesSet.GetWidth ();	long height = slicesSet.GetHeight ();		for (long z = 0; z < depth; z++)	{		for (long y = 0; y < height; y++)		{			for (long x = 0; x < width; x++)			{				if (slicesSet. GetPixelValue (x, y, z) & region)				{					center += C3DPoint(x, y, z);					weight++;				}			}		}	}		if (weight != 0)	{		center.fX /= weight;		center.fY /= weight;		center.fZ /= weight;	}		fCenter = center;	if (kScaleTriangles)	{		fCenter.Scale(kScaleFactor);	}	fWeight = weight;}