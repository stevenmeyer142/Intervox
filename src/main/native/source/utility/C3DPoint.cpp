// C3DPoint.cp// Created by Steve on Wed, Oct 28, 1998 @ 4:01 PM.#include "NativeOpenGL.h"#ifndef __C3DPoint__#include "C3DPoint.h"#endif#include "math.h"C3DPoint::C3DPoint(float x, float y, float z)  :					fX(x), fY(y), fZ(z){}C3DPoint::~C3DPoint(){}#pragma segment MainC3DPoint& C3DPoint::operator+=(const C3DPoint& pt){	fX += pt.fX;	fY += pt.fY;	fZ += pt.fZ;	return *this;}#pragma segment MainC3DPoint& C3DPoint::operator-=(const C3DPoint& pt){	fX -= pt.fX;	fY -= pt.fY;	fZ -= pt.fZ;		return *this;}#pragma segment MainC3DPoint C3DPoint::operator-() const{	return C3DPoint(-fX, -fY, -fZ);}#pragma segment MainC3DPoint::C3DPoint() : fX(0), fY(0), fZ(0){	}#pragma segment Mainbool C3DPoint::IsZero(){	return fX == 0 && fY == 0 && fZ == 0;}#pragma segment MainC3DPoint C3DPoint::Abs() const{	return C3DPoint(fX < 0 ? -fX : fX,					fY < 0 ? -fY : fY,					fZ < 0 ? -fZ : fZ);}#pragma segment #if !kOpenGLTQ3Vector3D C3DPoint::GetQD3Vector(){	TQ3Vector3D result;	result.x = fX;	result.y = fY;	result.z = fZ;		return result;}#endif#pragma segment Mainfloat C3DPoint::Length(){	float result = fX * fX + fY * fY + fZ * fZ;	return sqrt(result);}#pragma segment Mainvoid C3DPoint::Scale(float factor){	fX *= factor;	fY *= factor;	fZ *= factor;}#pragma segment MainC3DPoint::C3DPoint(const C3DPoint &other) :				fX(other.fX), fY(other.fY), fZ(other.fZ){	}#pragma segment Mainvoid C3DPoint::Normalize(){	float length = Length ();		if (length != 0)	{		Scale(1.0f / length);	}}#pragma segment MainC3DPoint C3DPoint::operator+(const C3DPoint& pt) const{	return C3DPoint(*this) += pt;}#pragma segment MainC3DPoint C3DPoint::CrossProduct(const C3DPoint& pt) const{	float x = fY * pt.fZ - fZ * pt.fY;	float y = fZ * pt.fX - fX * pt.fZ;	float z = fX * pt.fY - fY * pt.fX;		return C3DPoint(x, y, z);}